{"meta":{"title":"泾流的龙窝","subtitle":"","description":"海鲜龙小窝","author":"Zielorem","url":"https://zielorem.github.io","root":"/"},"pages":[{"title":"categories","date":"2023-07-15T18:54:05.000Z","updated":"2023-07-15T18:54:05.071Z","comments":true,"path":"categories/index.html","permalink":"https://zielorem.github.io/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2023-07-15T17:59:23.000Z","updated":"2023-07-15T17:59:23.738Z","comments":true,"path":"links/index.html","permalink":"https://zielorem.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-07-15T18:52:18.000Z","updated":"2023-07-15T18:52:18.251Z","comments":true,"path":"tags/index.html","permalink":"https://zielorem.github.io/tags/index.html","excerpt":"","text":""},{"title":"Gallery","date":"2023-10-31T05:44:55.000Z","updated":"2023-10-31T05:47:00.676Z","comments":true,"path":"masonry/index.html","permalink":"https://zielorem.github.io/masonry/index.html","excerpt":"","text":""}],"posts":[{"title":"互联网极端情绪传播的传染病模型","slug":"extreme-polarization","date":"2023-07-13T12:40:22.000Z","updated":"2025-05-30T04:39:28.195Z","comments":true,"path":"2023/07/13/extreme-polarization/","link":"","permalink":"https://zielorem.github.io/2023/07/13/extreme-polarization/","excerpt":"","text":"当前，互联网的去抑制效应愈发明显，去抑制效应下产生的极端情绪通过社交网络传播。在此种效应与环境下，个体在线表达的意见不一定反映个体的实际意见，而趋向于放大个人对某事的实际感受，此种现象被称为意见放大。放大后的意见相较个体的实际意见更为强烈，此种行为旨在通过以更肯定或更否定的情绪扭曲原始意见，从而吸引注意力。社交媒体滋生了众多极端的意见。这些意见一般具有以下其中几个特征： 在连续意见模型中，极端意见值达到最初意见范围的极值或超出一般的意见值范围； 随时间增长，异常意见值于不同意见边界值上下浮动，或伴随剧烈波动； 部分个体所表达的意见值与其实际意见值不在同一区间内； 异常意见一般包括毫无根据的假设与概括，或选择性引用与编辑。 通过意见放大，当前社交媒体中的极端程度日益增长，使其成为了群体极化的潜在原因之一。先前的群体极化研究工作主要围绕个体之间意见的相互作用展开，而Lim与Bentley所提出的社会意见放大模型（Social Opinion Amplification Model, SOAM）则假设意见通过意见放大可能会偏向于更极端的情绪，从而识别在人群中产生极端极化所需的最小特征。 社会意见放大模型社会意见放大模型（SOAM）由个体网络组成。与有界置信模型类似，其中个体的意见是连续的，且个体在每个时间步骤中相互影响。除普通意见外，该模型通过意见放大现象引入了放大化意见（amplified version of opinion ）的概念，并基于Hegselmann–Krause模型进行研究。 对于在线社交网络中的个体A与个体B，若B在没有收到回应的情况下赞同A，则会导致A影响B，而B不影响A。因此，该模型通过一个随机有向图网络模拟社交网络结构，其中每个个体节点平均包括个连接，其中。假设网络中的个体在时间时具有初始观点，其范围为内的随机数，左极值代表极度否定的观点，而右极值代表极度肯定的观点。则时间时个体的观点为 其中为时间点时个体在前一时间点的观点，为时间点时与个体相连接的个体集合，个体的观点与其相连个体观点的差异在与Hegselmann–Krause模型类似的阈值内，即 而个体时间点时所表达的放大化意见为 其中，为判断个体是否将在时间时放大其观点的参数，其值由随机生成的概率决定；为个体在时间时的观点放大程度，其值为内的随机数；为观点放大程度的上限，其范围为。观点值可能随时间增长而超出初始意见值范围。由此可见，SOAM相较Hegselmann–Krause模型与SIEM的差异如下表所示。 模型 网络 意见表达形式 意见更新形式 个体影响力 HK有界置信模型 全连接 个体的想法与其所表达的意见完全一致 当且仅当个体间观点的差值小于阈值 每个个体均影响其余所有个体 SIEM 随机连接，每个个体均与平均5个其他个体连接，并伴随时间生成新网络 个体的想法与其所表达的意见完全一致 当且仅当个体的确定性低于与其互动的其他个体的平均确定性 影响仅发生于相互连接的个体间 SOAM 随机连接，每个个体与平均2个、5个或10个个体连接 部分个体进行意见放大 当且仅当个体间观点的差值小于阈值 影响仅发生于相互连接的个体间 基于意见放大将导致群体极化的假设，Lim与Bentley研究了意见放大在不同置信度阈值下对意见动态的影响，其将不包含意见放大的基础模型与包含意见放大的改进模型进行比较，即以下两种模型 在置信阈值及下不包含意见放大的基础模型 包含意见放大个体的改进模型，其中意见放大的个体比率为及，个体进行意见放大的概率为，意见放大程度为，置信阈值为及 模拟结果如下图所示，其中，， 由结果可知，网络在没有意见扩大的情况下，无论意见极化结果为单簇或多簇，意见范围总是位于初始范围内。而当个体存在意见放大行为后，超界意见将诱导极端极化现象发生。同时，存在意见放大行为的个体比率越多，极端极化现象将更快形成且规模更大。SOAM表明意见放大现象会在人群中造成极端的两极分化，但过度极端的言论会导致个体无法再与其他人相关。当置信阈值高时，冲突水平将迅速下降。 情绪传播模型在Anderson与May的基础传染病模型中，个体存在“易感”与“感染”两种基础状态。“易感”代表个体暂时未感染某种疾病，而“感染”指代个体已患有某种疾病。当易感者与感染者接触后，这种疾病可能将以传播率传播于易感者。个体被感染后，无论其与易感或患病个体的接触情况如何，其均以恒定的速率从疾病中恢复。在一类疾病模型中，传染过程大致为易感-感染-恢复（SIR）三个状态，康复后个体对感染进一步产生免疫力，并重新进入至“恢复”状态。部分不具有免疫力的传染性疾病在康复后将重新恢复至易感状态，其过程被划分为易感-感染-易感（SIS）三个状态。 与传染性疾病不同，情绪在个体中可能多次因传播以外的自发因素发生。因此，Alison与David扩展了SIS模型，使得模型中未受感染的个体以恒定速率自发感染，而与受感染者的接触者无关。被修改后的模型称为SISa，其模式为 在该模型中，指代患病个体，指代易感个体。个体状态可通过三种过程改变 受感染个体以传染率传播于易感接触者 易感个体以感染率自发感染 受感染者以速率自发恢复至易感状态 因此，该模型中个体被感染的变化率为，其中为个体所接触被感染者数目。相应微分方程为 其中指代易感个体总数，指代患病个体总数，个体总数为恒定值。由方程可知，个体从易感过渡至被感染状态的概率为受感染接触者数量的线性函数。对于小于状态过渡平均时间的时间间隔分隔的数据点，个体在后从易感到受感染的概率可由给出，而个体在后恢复至易感状态的过渡概率可由给出，被测时间间隔必须大于状态的平均时长以在时间间隔内保持低水平的双重过渡概率。 极端情绪传播作为原生情绪种类之一，极端情绪可通过社交媒体途径传播，也可以自发形式出现。为引人注目，社交媒体中部分个体自发出现极端情绪，并将情绪通过极端言论形式传播。在融合SOAM与SISa后，假设个体于时间的观点以概率发生极端情绪突变，接触该情绪的其他个体在传染病模型下的感染率与有界置信模型的阈值概念相当。同时，与SISa模型不同，极端情绪可通过其他个体的反复传播而加剧，此时其恢复速率为，从而可能产生负恢复速率以加剧极端情绪。 因此，可通过以下方式阻断群体极化加剧 减少或清除个体接触的连接，便于个体以速率恢复 冻结极端情绪个体，阻止其进一步传播 加入意见值介于间的平衡意见 参考文献[1] Condie, S. A. &amp; Condie, C. M. Stochastic events can explain sustained clustering and polarisation of opinions in social networks. Sci. Rep. 11, 1355 (2021). [2] Cinelli, M., Morales, G. D. F., Galeazzi, A., Quattrociocchi, W. &amp; Starnini, M. The echo chamber effect on social media. Proc. Natl. Acad. Sci. U.S.A. 118, e2023301118 (2021). [3] DeGroot, M. H. Reaching a consensus. J. Am. Stat. Assoc. 69, 118–121 (1974). [4] Deffuant, G., Neau, D., Amblard, F. &amp; Weisbuch, G. Mixing beliefs among interacting agents. Adv. Complex Syst. 3, 11 (2001). [5] Hegselmann, R. &amp; Krause, U. Opinion dynamics and bounded confidence models, analysis, and simulation. J. Artif. Soc. Soc. Simul. 5, 33 (2002). [6] Anderson R. M., May R. M.1991Infectious diseases of humans: dynamics and control. Oxford, UK: Oxford University Press [7] Lim, S., Bentley, P.J. Opinion amplification causes extreme polarization in social networks. Sci Rep 12, 18131 (2022). [8]Hill AL, Rand DG, Nowak MA, Christakis NA. Emotions as infectious diseases in a large social network: the SISa model. Proc Biol Sci. 2010 Dec 22;277(1701):3827-35. doi: 10.1098/rspb.2010.1217. Epub 2010 Jul 7. PMID: 20610424; PMCID: PMC2992714.","categories":[{"name":"opinion_dynamics","slug":"opinion-dynamics","permalink":"https://zielorem.github.io/categories/opinion-dynamics/"}],"tags":[{"name":"polarization","slug":"polarization","permalink":"https://zielorem.github.io/tags/polarization/"}]},{"title":"通过排列组合问题理解回溯算法","slug":"permutations-and-combinations","date":"2023-01-17T16:58:45.000Z","updated":"2025-05-30T04:39:27.007Z","comments":true,"path":"2023/01/18/permutations-and-combinations/","link":"","permalink":"https://zielorem.github.io/2023/01/18/permutations-and-combinations/","excerpt":"","text":"排列 Question 给定一个不含重复数字的数组nums，返回其所有可能的元素不重复的全排列。 以数组[1, 2, 3]为例，其总共可能含有的全排列数为 个。一般情况下，我们会逐个选择排列中的元素以组成新排列。例如： 首先选择1作为排列的第一位，则第二位可以选择的元素有2和3 选择2作为排列的第二位，则第三位可以选择的元素仅有3 选择3作为排列的第三位，则该排列为[1, 2, 3] 第三步完成后，由于排列已经形成，此时需要考虑其他可能存在的排列 重新考虑此时排列的第三位，但3已被选过，且无其他选择，回退到上一位 重新考虑此时排列的第二位，由于2已被选过，因此可以选择3作为新排列的第二位 最后选择2作为新排列的第三位，则该排列为[1,3,2] 继续考虑其他可能存在的排列 重新考虑此时排列的第三位，但2已被选过，且无其他选择，回退到上一位 重新考虑此时排列的第二位，由于2与3均已被选过，且无其他选择，回退到上一位 重新考虑此时排列的第一位，由于1已被选过，可以选择的元素还有2与3 选择2作为新排列的第一位… 依此规律，我们可以生成所有可能存在的6个排列。将这些排列生成过程以树的形式表示后不难发现，其规律类似于之前提到的DFS算法，因此该问题可以借助DFS算法实现。另外，所谓的“重新考虑”实际上是将排列复原至前一个状态上，尔后重新选择新元素，这种类似“时光倒流”的倒退算法即为著名的回溯算法。借助回溯算法，可以解决存在多个步骤且每个步骤有多种实现方法的问题（例如本文的排列与组合问题）。 首先确定用于生成排列的容器、变量与函数 123456789//用于生成排列的主要容器vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums){ vector&lt;vector&lt;int&gt;&gt; ans; //用于存储所有全排列结果的容器 vector&lt;int&gt; path; //用于存储全排列生成步骤（或路径）的容器（即问题分析中所使用的栈） vector&lt;int&gt; visited(n, 0); //用于存储元素选择状况的容器 int n = nums.size(); //即单个全排列的长度 dfs(ans, path, nums, visited, n); //DFS算法 return ans; //主函数最终返回所有全排列结果} 尔后定义DFS算法的具体内容 12345678910111213141516171819void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; path, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; visited, int n){ //（确定终止条件）当步骤执行至某全排列的长度等于原数组长度时，该排列生成完毕 if(path.size() == n){ ans.push_back(path); //将该全排列推入结果容器中 return; //并返回 } //用于选择元素的for循环，依次逐个选择元素直至选择完毕 //在nums包含的n个元素中进行选择 for(int i = 0;i &lt; n;i++){ //若某个元素未被选择 if(visited[i] == 0){ visited[i] = 1; //则将其选择，并将其状态设置为已选择 path.push_back(nums[i]); //将被选择的元素推入步骤容器中（前进） dfs(ans, path, nums, visited, n); //并对其执行DFS操作（继续选择该排列的下一位） path.pop_back(); //该排列生成完毕后将该元素推出容器（回溯） visited[i] = 0; //并设置为未选择（便于之后重新选择） } }} 其整体运行过程与前文分析部分所展示的过程一致，完整代码为 1234567891011121314151617181920212223242526class Solution{public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; path, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; visited, int n){ if(path.size() == n){ ans.push_back(path); return; } for(int i = 0;i &lt; n;i++){ if(visited[i] == 0){ visited[i] = 1; path.push_back(nums[i]); dfs(ans, path, nums, visited, n); path.pop_back(); visited[i] = 0; } } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums){ vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; vector&lt;int&gt; visited(n, 0); int n = nums.size(); dfs(ans, path, nums, visited, n); return ans; }}; 组合 Question 给定两个整数n和k，返回范围 中所有可能的k个数的组合。 以数组[1,2,3]为例，此时若k值为2，则其总共可能含有的组合数为 个。组合问题与排列问题的区别在于前者不关注于组合内元素的排列顺序，更侧重于分析组合中存在哪些元素。因此，生成组合的过程大致为： 选择1作为组合的第一位，下一个可选元素有2和3 选择2作为组合的第二位，则该组合为[1, 2] 第二步完成后，由于组合已经形成，此时需要考虑其他可能存在的组合 回退至上一位 重新选择3作为组合的第二位，则该组合为[1, 3] 继续考虑其他可能存在的组合 回退至上一位，发现都已被选过，继续回退 重新选择2作为组合的第一位… 依此规律，我们可以生成所有可能存在的6种数组结果，其中包含了3种组合。由此可见，虽然其大致过程与处理排列问题时的流程一致，但在生成过程中难免会产生重复的组合。该生成过程在树结构下可表示为 因此，我们需要去除生成结果中的重复组合，即去除上图中冗余组合所属的“枝条”，该过程一般被称为剪枝操作。通过剪枝操作，可以保证所生成的组合均不重复。经过剪枝操作后，生成过程被简化为 首先确定用于生成组合的容器、变量与函数 1234567//用于生成组合的主要容器vector&lt;vector&lt;int&gt;&gt; combine(int n, int k){ vector&lt;vector&lt;int&gt;&gt; ans; //用于存储所有组合结果的容器 vector&lt;int&gt; path; //用于存储组合生成步骤（或路径）的容器（即问题分析中所使用的栈） dfs(n, k, start); //DFS算法 return ans; //主函数最终返回所有组合结果} 尔后定义DFS算法的具体内容 1234567891011121314void dfs(int n, int k, int start){ //（确定终止条件）当步骤执行至某组合的长度等于k时，该组合生成完毕 if(path.size() == k){ ans.push_back(path); //将该组合推入结果容器中 return; //并返回 } //用于选择元素的for循环，依次逐个选择元素直至选择完毕 //从start开始循环实际上为剪枝操作，通过大小关系保证了结果的不重复性 for(int i = start;i &lt;= n;i ++){ path.push_back(i); //选择元素推入容器（前进） dfs(n, k, i + 1); //执行DFS操作（选择下一位） path.pop_back(); //将元素推出容器（回溯） }} 在该算法中，剪枝操作实际上通过for循环实现，它可以保证后续位的元素一定大于相邻的前一个元素。从组合的生成结果[[1, 2], [1, 3], [2, 3]]不难看出，该结果符合该特征。因此完整代码为 1234567891011121314151617181920class Solution{public: void dfs(int n, int k, int start){ if(path.size() == k){ ans.push_back(path); return; } for(int i = start;i &lt;= n;i ++){ path.push_back(i); dfs(n, k, i + 1); path.pop_back(); } } vector&lt;vector&lt;int&gt;&gt; combine(int n, int k){ vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path; dfs(n, k, 1); //从1开始选择 return ans; }}; 总结从上述排列与组合的问题中可以发现，这些问题所使用的回溯算法结构类似，大致结构为 1234567891011void dfs(所需参数){ if(路径终止条件){ 将路径结果推入结果容器中; return; } for(int i = 初始（选择）值; 步骤终止条件; i++){ path.push_back(所处理的对象); dfs(所需参数); path.pop_back(); }} 该结构即经典的回溯算法结构。一般情况下，由于回溯算法与DFS算法及栈结构关系密切，鉴于各个问题的特殊性，该结构中可能会添加visited数组以验证选择情况，或进行剪枝操作等，但该主框架通用于绝大部分可以通过回溯算法处理的问题。","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://zielorem.github.io/tags/algorithm/"}]},{"title":"通过“溟痕”理解多源BFS","slug":"sealed-floors","date":"2023-01-15T11:35:42.000Z","updated":"2025-05-30T04:39:26.782Z","comments":true,"path":"2023/01/15/sealed-floors/","link":"","permalink":"https://zielorem.github.io/2023/01/15/sealed-floors/","excerpt":"","text":"最近打舟肉鸽溟痕关卡“蔓延”时，看到溟痕扩散的方式感觉有点似曾相识，因此有想到如下问题。 我们假设关卡地板为m*n的网格grid，每个单元格可能存在以下值及其对应状态： 值为0代表特殊地块，溟痕无法扩散至该地形上 值为1代表干净地块（即未被扩散） 值为2代表溟痕地块（即已被扩散） 每过12秒，溟痕会向所在单元格周围四个方向上的相邻单元格扩散。编写算法返回直到grim中不存在干净地块为止所需经过的最小时间。若不可能，则返回-1。 备注：PRTS Wiki中关于溟痕扩散机制的解释 溟痕会向四个方向同时扩散，其扩散方式类似于上一篇“岛屿最大面积问题”中BFS的遍历方式。在“蔓延”关卡中，初始状态下并不存在溟痕地块，仅当溟痕怪通过其自身机制在其所处地块上生成溟痕后，关卡中方才存在第一块溟痕，尔后该溟痕会根据BFS思想向地图中其余地块扩散溟痕。 但在部分关卡（如SN-EX-6）中，初始状态下即存在多块溟痕地块，这些地块会同时基于BFS对周围地块进行溟痕扩散，此即多源BFS。在扩散过程中，为了实时统计场上是否仍存在干净地块，需要在扩散前确定干净地块的数量。同时，由于BFS基于队列运行，所有溟痕地块在进行扩散前需要先入队，并在置于队首时方才进行扩散并出队，因此可以通过该过程对溟痕地块总数进行统计，从而确定该批次即将扩散的溟痕地块总数。每有一个元素入队，则溟痕地块的数量较先前多一块。初次进行溟痕扩散操作时，地块及队列的状态为 在队列中仍存在元素时，溟痕地块在扩散过程中若接触到某方向相邻的干净地块，则场上存在的干净地块相应地少一块，同时被扩散的新溟痕地块入队，直至队列被清空（即溟痕地块均扩散完毕且不再有新的溟痕地块生成）。因此，第二次进行溟痕扩散操作时，地块及队列的状态为 最终地块与队列的状态为 值得注意的是，由于每过12秒溟痕所进行的扩散是同时进行的，因此仅在当前批次（即当前层）的溟痕均扩散完毕后，方才将所需时间增加12秒，并进行新入队的溟痕地块的扩散行动。 首先确认地图中存在的干净地块与溟痕地块的数目，并建立用于溟痕扩散的队列 1234567891011121314151617int row = grid.size();int col = grid[0].size();queue&lt;pair&lt;int, int&gt;&gt; que;vector&lt;vector&lt;int&gt;&gt; visited(row, vector&lt;int&gt;(col, 0));int clean = 0;int sealed = 0;for(int i = 0;i &lt; row;i++)&#123; for(int j = 0;j &lt; col;j++)&#123; if(grid[i][j] == 2)&#123; que.push(make_pair(i, j)); sealed++; &#125; else if(grid[i][j] == 1)&#123; clean++; &#125; &#125;&#125; 统计完毕后，此时若地图中干净地块与溟痕地块数目均仍为0（即全为特殊地块），则溟痕无法进行扩散，直接返回0 123if(sealed == 0 &amp;&amp; clean == 0)&#123; return 0;&#125; 根据队列开始进行溟痕扩散前，对所需时间进行初始化 12#define TIME 12int time = -TIME; 尔后开始向四个方向进行溟痕扩散，且在队列非空或未接触到边界前该过程会在相应方向上持续 1234567891011121314151617181920212223242526272829303132333435363738394041while(!que.empty())&#123; int size = que.size(); //队列长度，即当前待扩散的溟痕地块数目 for(int i = 0;i &lt; size;i++)&#123; int x = que.front().first; int y = que.front().second; que.pop(); //向下扩散 if(x + 1 &lt; row)&#123; if(grid[x + 1][y] == 1)&#123; grid[x + 1][y] = 2; clean--; que.push(make_pair(x + 1, y)); //新溟痕地块入队 &#125; &#125; //向上扩散 if(x - 1 &gt;= 0)&#123; if(grid[x - 1][y] == 1)&#123; grid[x - 1][y] = 2; clean--; que.push(make_pair(x - 1, y)); //新溟痕地块入队 &#125; &#125; //向右扩散 if(y + 1 &lt; col)&#123; if(grid[x][y + 1] == 1)&#123; grid[x][y + 1] = 2; clean--; que.push(make_pair(x, y + 1)); //新溟痕地块入队 &#125; &#125; //向左扩散 if(y - 1 &gt;= 0)&#123; if(grid[x][y - 1] == 1)&#123; grid[x][y - 1] = 2; clean--; que.push(make_pair(x, y - 1)); //新溟痕地块入队 &#125; &#125; &#125; time += TIME; //仅在当前队列清空后，同一层的溟痕均扩散完毕，方才增长时间&#125; 队列清空后，若场上不再存在干净地块，则返回溟痕扩散所需总时间，否则返回-1 1234if(clean == 0)&#123; return time;&#125;return -1; 对上述内容进行整合后，完整代码为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#define TIME 12class Solution&#123;public: int floorsSealing(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; int row = grid.size(); int col = grid[0].size(); queue&lt;pair&lt;int, int&gt;&gt; que; vector&lt;vector&lt;int&gt;&gt; visited(row, vector&lt;int&gt;(col, 0)); int clean = 0; int sealed = 0; for(int i = 0;i &lt; row;i++)&#123; for(int j = 0;j &lt; col;j++)&#123; if(grid[i][j] == 2)&#123; que.push(make_pair(i, j)); sealed++; &#125; else if(grid[i][j] == 1)&#123; clean++; &#125; &#125; &#125; if(sealed == 0 &amp;&amp; clean == 0)&#123; return 0; &#125; int time = -TIME; while(!que.empty())&#123; int size = que.size(); //队列长度，即当前待扩散的溟痕地块数目 for(int i = 0;i &lt; size;i++)&#123; int x = que.front().first; int y = que.front().second; que.pop(); //向下扩散 if(x + 1 &lt; row)&#123; if(grid[x + 1][y] == 1)&#123; grid[x + 1][y] = 2; clean--; que.push(make_pair(x + 1, y)); //新溟痕地块入队 &#125; &#125; //向上扩散 if(x - 1 &gt;= 0)&#123; if(grid[x - 1][y] == 1)&#123; grid[x - 1][y] = 2; clean--; que.push(make_pair(x - 1, y)); //新溟痕地块入队 &#125; &#125; //向右扩散 if(y + 1 &lt; col)&#123; if(grid[x][y + 1] == 1)&#123; grid[x][y + 1] = 2; clean--; que.push(make_pair(x, y + 1)); //新溟痕地块入队 &#125; &#125; //向左扩散 if(y - 1 &gt;= 0)&#123; if(grid[x][y - 1] == 1)&#123; grid[x][y - 1] = 2; clean--; que.push(make_pair(x, y - 1)); //新溟痕地块入队 &#125; &#125; &#125; time += TIME; //仅在当前队列清空后，同一层的溟痕均扩散完毕，方才增长时间 &#125; if (clean == 0)&#123; return time; &#125; return -1; &#125;&#125;; Python下代码为 123456789101112131415161718192021class Solution: def floorsSealing(self, grid: List[List[int]]) -&gt; int: row, col, time = len(grid), len(grid[0]), 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = [] #溟痕地块入队 for i in range(row): for j in range(col): if grid[i][j] == 2: queue.append((i, j, time)) #BFS while queue: i, j, time = queue.pop(0) for di, dj in directions: if 0 &lt;= i + di &lt; row and 0 &lt;= j + dj &lt; col and grid[i + di][j + dj] == 1: grid[i + di][j + dj] = 2 queue.append((i + di, j + dj, time + 12)) for row in grid: if 1 in row: return -1 return time","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://zielorem.github.io/tags/algorithm/"}]},{"title":"关于完美二叉树的指针填充策略","slug":"fill-pointer-of-trees","date":"2023-01-14T15:34:36.000Z","updated":"2025-05-30T04:39:27.955Z","comments":true,"path":"2023/01/14/fill-pointer-of-trees/","link":"","permalink":"https://zielorem.github.io/2023/01/14/fill-pointer-of-trees/","excerpt":"","text":"Question 给定一个完美二叉树，其所有叶子结点均在同一层，且每个父节点均有两个子节点，其定义为 123456struct Node&#123; int val; Node *left; Node *right; Node *next;&#125; 编写算法填充其每个next指针，使该指针指向其下一个右侧节点。若不存在下一个右侧节点，则将next指针设置为NULL。缺省状态下，所有next指针均被设置为NULL。 通过分析完美二叉树的结构，可以发现位于该树每一层最右边的结点的next指针均指向NULL，且均为右节点或根结点。因此 若该层最左侧节点为空，则该层不存在 若某节点的父节点指向NULL，则该父节点的右节点一定指向NULL 因此，需要通过同时分析两层的状况以进行指针填充操作。即 父节点的左节点一定指向其右节点 当父节点的next指针不为空时，其右节点指向该父节点的next指针所指向的节点的左节点 当父节点的next指针为空时，其右节点也指向NULL 首先，由于指针填充操作需要同时分析两层的状况，因此需要建立反映相邻两层状况的指针cur与pre 12Node* cur = root-&gt;left-&gt;left;Node* pre = root-&gt;left; 当根节点为空时，直接返回空指针，即 123if(root == nullptr)&#123; return nullptr;&#125; 当根节点不存在子结点时，直接返回根结点。由于该树为完美二叉树，因此若某节点的左节点或右节点不存在，则该节点的子结点均不存在 123if(root-&gt;left == nullptr)&#123; return root;&#125; 对于某节点的左节点，其next指针一定指向该结点的右节点，即 123if(root-&gt;left != nullptr)&#123; root-&gt;left-&gt;next = root-&gt;right;&#125; 对于某节点的右节点 若该右节点的父节点的next指针不为空，则该右节点指向其父节点的next指针所指向的节点的左节点，即 123if(root-&gt;next != nullptr)&#123; root-&gt;right-&gt;next = root-&gt;next-&gt;left;&#125; 若该右节点的父节点的next指针为空，则该右节点的next指针亦为空，即 123if(root-&gt;next == nullptr)&#123; root-&gt;right-&gt;next = nullptr;&#125; 依据此逻辑，可以通过cur指针与pre指针对根结点的后续节点进行指针填充操作。由于父节点的左节点与右节点均存在，因此cur指针需要沿着next指针向右行进，并对该层其他的父节点执行操作。上文提出，若某层最左侧节点为空，则该层不存在。因此，操作的终止条件为cur指针指向NULL或pre指针指向NULL。 当pre指针指向NULL时，所有cur所在层的节点的父节点均遍历完毕。此时，需要将pre指针与cur指针同时推进至下一层，即 12pre = cur;cur = cur-&gt;left; 当cur指针指向NULL时，cur指针所指节点的左节点不存在，即下一层所有节点均不存在。因此，当前cur指针所在节点为叶子节点，cur指针无法继续前行，整体遍历操作执行完毕 将上述代码段整合后，完整代码为 123456789101112131415161718192021222324252627class Solution&#123;public: Node* connect(Node* root)&#123; if(root == nullptr) return nullptr; else if(root-&gt;left == nullptr) return root; else&#123; root-&gt;left-&gt;next = root-&gt;right; &#125; Node* cur = root-&gt;left-&gt;left; Node* pre = root-&gt;left; while(cur != nullptr)&#123; while(pre != nullptr)&#123; pre-&gt;left-&gt;next = pre-&gt;right; if(pre-&gt;next != nullptr)&#123; pre-&gt;right-&gt;next = pre-&gt;next-&gt;left; &#125; else&#123; pre-&gt;right-&gt;next = nullptr; &#125; pre = pre-&gt;next; &#125; pre = cur; cur = cur-&gt;left; &#125; return root; &#125;&#125;; Python下算法为 123456789101112class Solution: def connect(self, root: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: pre = root while pre: cur = pre while cur and cur.left: cur.left.next = cur.right if cur.next: cur.right.next = cur.next.left cur = cur.next first = first.left return root","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://zielorem.github.io/tags/algorithm/"}]},{"title":"通过BFS/DFS解决岛屿最大面积问题","slug":"island-proportion","date":"2023-01-13T06:57:50.000Z","updated":"2025-05-30T04:39:27.483Z","comments":true,"path":"2023/01/13/island-proportion/","link":"","permalink":"https://zielorem.github.io/2023/01/13/island-proportion/","excerpt":"","text":"Question 当前存在一个大小为m*n的二进制矩阵grid，假设岛屿是由一些相邻的1构成的组合，即两个1必须在水平或垂直的四个方向上相邻（假设grid外的位置全为0），岛屿的面积即岛上值为1的单元格的数目。计算并返回grid中最大的岛屿面积。若不存在岛屿，则返回面积为0。 由于每个岛屿均被水包围，因此在登陆岛屿后，对岛上的每一寸土地进行递归即可计算当前岛屿面积，最后返回所有岛屿中所得的最大面积即可。登陆岛屿后的具体步骤为 以此时所处位置为中心，向上、下、左、右四个方向前进 若发现在该方向前进后抵达的新地点为水或为已抵达过的地点，则停止以该方向前进 若发现在该方向前进后抵达的新地点为未抵达过的地点，则在对其进行标记后，重复步骤1 此即深度优先搜索方法，该方法实际上将所抵达的点均压至栈中，当新入栈的点抵达边界条件时，该点会在执行完毕后出栈，直至栈被清空。而将执行操作的数据结构从栈替换为队列后，算法会转变为广度优先搜索方法，即每次执行操作时均从队首取出所储存的点，并将接下来需要遍历的点置于队尾，直至队列被清空。 DFS在以grid中每一寸土地为中心进行递归前，需要确定边界终止条件，即遍历位置抵达grid的四个边缘外的时刻。其代码为 1234567int i, j;if(i == grid.size() || i &lt; 0)&#123; return 0;&#125;else if(j == grid[0].size() || j &lt; 0)&#123; return 0;&#125; 当所抵达的点为陆地时，需要将其标记为已抵达过的点，从而避免后续递归点再次对其进行遍历。因此，可将遍历后的点直接设置为0，此即著名的沉岛策略。尔后在对上、下、左、右四个方向上的地点进行递归，并同时统计该岛屿面积。加入边界终止条件后，其代码为 12345678910111213int getProportion(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j)&#123; if(i == grid.size() || i &lt; 0)&#123; return 0; &#125; else if (j == grid[0].size() || j &lt; 0)&#123; return 0; &#125; if(grid[i][j] == 1)&#123; grid[i][j] == 0 return 1 + getProportion(grid, i + 1, j) + getProportion(grid, i - 1, j) + getProportion(grid, i, j + 1) + getProportion(grid, i, j - 1); &#125; return 0;&#125; 尔后，通过主函数遍历grid中的每一个点，确定每个岛屿的面积大小，并实时更新最大岛屿面积，完整代码为 123456789101112131415161718192021222324252627282930class Solution&#123; int getProportion(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j)&#123; if(i == grid.size() || i &lt; 0)&#123; return 0; &#125; else if (j == grid[0].size() || j &lt; 0)&#123; return 0; &#125; if(grid[i][j] == 1)&#123; grid[i][j] == 0 return 1 + getProportion(grid, i + 1, j) + getProportion(grid, i - 1, j) + getProportion(grid, i, j + 1) + getProportion(grid, i, j - 1); &#125; return 0;&#125;public: int maxProportionOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; int maxProportion = 0; int proportion = 0; for(int i = 0;i &lt; grid.size();i++)&#123; for(int j = 0;j &lt; grid[0].size();j++)&#123; if(grid[i][j] == 1)&#123; proportion = getProportion(grid, i, j); maxProportion = maxProportion &lt; proportion ? proportion : maxProportion; &#125; &#125; &#125; return maxProportion; &#125;&#125;; Python下代码为 1234567891011121314151617class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int: maxArea = 0 def getArea(x, y): if not (0 &lt;= x &lt; len(grid) and 0 &lt;= y &lt; len(grid[0])): return 0 if grid[x][y] == 1: grid[x][y] == 0 return 1 + getArea(x - 1, y) + getArea(x + 1, y) + getArea(x, y + 1) + getArea(x, y - 1) return 0 for m in range(len(grid)): for n in range(len(grid[0])): if grid[m][n] == 1: maxArea = max(getArea(m, n), maxArea) return maxArea BFS 首先建立队列，并设置操作执行过程中的终止条件。与DFS算法相同，该方法依旧采用沉岛策略，并根据队列顺序依次遍历岛屿中的点。 1234567891011121314151617181920212223242526272829void getArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j)&#123; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;i, j&#125;); while(!q.empty())&#123; auto t = q.front(); q.pop(); int i = t.first, j = t.second, area = 0; if(i &lt; 0 || j &lt; 0 || i == grid.size() || j == grid[0].size())&#123; continue; &#125; else if(grid[i][j] == 0)&#123; continue; &#125; grid[i][j] == 0; area++; if (i &gt; 0 &amp;&amp; grid[i - 1][j] == 1)&#123; q.push(&#123;i - 1, j&#125;); &#125; if (j &gt; 0 &amp;&amp; grid[i][j - 1] == 1)&#123; q.push(&#123;i, j - 1&#125;); &#125; if(i &lt;= grid.size() &amp;&amp; grid[i + 1][j] == 1)&#123; q.push(&#123;i + 1, j&#125;); &#125; if(j &lt;= grid[0].size() &amp;&amp; grid[i][j + 1] == 1)&#123; q.push(&#123;i, j + 1&#125;); &#125; &#125;&#125; 尔后，建立主函数遍历grid中的每个点，其完整代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution&#123;public: int area = 0; int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid)&#123; int maxArea = 0; for(int i = 0;i &lt; grid.size();i++)&#123; for(int j = 0;j &lt; grid[0].size();j++)&#123; if(grid[i][j] == 1)&#123; area = 0; getArea(grid, i, j); maxArea = max(area, maxArea); &#125; &#125; &#125; return maxArea; &#125; void getArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j)&#123; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(&#123;i, j&#125;); while(!q.empty())&#123; auto t = q.front(); q.pop(); int i = t.first, j = t.second; if(i &lt; 0 || j &lt; 0 || i == grid.size() || j == grid[0].size())&#123; continue; &#125; else if(grid[i][j] == 0)&#123; continue; &#125; grid[i][j] == 0; area++; if (i &gt; 0 &amp;&amp; grid[i - 1][j] == 1)&#123; q.push(&#123;i - 1, j&#125;); &#125; if (j &gt; 0 &amp;&amp; grid[i][j - 1] == 1)&#123; q.push(&#123;i, j - 1&#125;); &#125; if(i &lt;= grid.size() &amp;&amp; grid[i + 1][j] == 1)&#123; q.push(&#123;i + 1, j&#125;); &#125; if(j &lt;= grid[0].size() &amp;&amp; grid[i][j + 1] == 1)&#123; q.push(&#123;i, j + 1&#125;); &#125; &#125; &#125;&#125;; Python下代码为 12345678910111213141516171819class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int: def getArea(grid, x, y): queue = [[x, y]] while queue: [x, y] = queue.pop(0) if 0 &lt;= x &lt; len(grid) and 0 &lt;= y &lt; len(grid[0]) and grid[x][y]: grid[x][y] == 0 self.area += 1 queue += [[x - 1, y], [x + 1, y], [x, y + 1], [x, y - 1]] return self.area maxArea = 0 for i in range(len(grid)): for j in range(len(grid[0])): if(grid[i][j] == 1): self.area = 0 maxArea = max(getArea(grid, i, j), maxArea) return maxArea","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://zielorem.github.io/tags/algorithm/"}]},{"title":"通过滑动窗口确定无重复字符的最长子串","slug":"slide-window-ascii","date":"2023-01-12T06:32:23.000Z","updated":"2025-05-30T04:39:26.425Z","comments":true,"path":"2023/01/12/slide-window-ascii/","link":"","permalink":"https://zielorem.github.io/2023/01/12/slide-window-ascii/","excerpt":"","text":"Question 给定一个字符串s，编写算法找出其中不含有重复字符的最长子串的长度。 题设要求子串中不出现重复字符，因此可以在遍历过程中将出现过的字符的位置记录在数组中。在出现过的字符再次出现后，当前子串便不再满足条件，因此需要更新子串的起始位置从而重建新子串。 同时，在遍历过程中还需记录每一步的子串长度，并将其与最长子串长度相比较，若大于最长子串长度则对其进行更新。 以字符串“abcabc”为例，首先定义用于遍历数组与充当子串尾指针的变量end，以及子串起始指针start。为了避免子串中出现重复字符，定义一个数组index，其具有两个功能 用于记录字符串中每个字符在之前是否出现过 用于存储出现重复字符时start应移动到的位置 其中的127位分别对应ASCII码中的前127位。最后定义用于记录子串当前长度的变量length与子串最大长度max_length。 12345int start = 0;int end;int index[128] = &#123;0&#125;;int length = 0;int max_length = 0; 对于遍历过程中遍历到的每个字符，定义其index值为end + 1。若某个字符的index值大于start，则说明start值需要更新，即子串中出现了重复字符。此时，在更新子串前，记录当前子串的长度，将其与最大长度比较，并根据比较结果对其进行更新。具体代码如下： 123456789101112for(end = 0;s[end]!=&#x27;\\0&#x27;;end++)&#123; if(index[s[end]] &gt; start)&#123; length = end - start; if(length &gt; max_length)&#123; max_length = length; &#125; start = index[s[end]]; //更新start &#125; index[s[end]] = end + 1; //记录字符串中每个字符的index值&#125;length = end - start;return length&gt;max_length?length:max_length; 依照此逻辑执行操作直至遍历至字符串结尾，其完整代码如下： 123456789101112131415int lengthOfLongestSubstring(char* s)&#123; int start = 0, end, index[128] = &#123;0&#125;, length = 0, max_length = 0; for(end = 0;s[end]!=&#x27;\\0&#x27;;end++)&#123; if(index[s[end]] &gt; start)&#123; length = end - start; if(length &gt; max_length)&#123; max_length = length; &#125; start = index[s[end]]; //更新start &#125; index[s[end]] = end + 1; //记录字符串中每个字符的index值 &#125; length = end - start; return length&gt;max_length?length:max_length;&#125; Python下代码如下 123456789101112131415class Solution(object): def lengthOfLongestSubstring(self, s): if not s: return 0 max_length = 0 start, end = 0, 0 for i, c in enumerate(s): if c not in s[start:end]: end += 1 else: start += s[start:end].index(c) + 1 end += 1 max_length = max(end - start, max_length) return max_length if max_length != 0 else len(s) ​","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://zielorem.github.io/tags/algorithm/"}]},{"title":"数组的翻转与轮转","slug":"rotate-array","date":"2023-01-08T06:47:42.000Z","updated":"2025-05-30T04:39:26.808Z","comments":true,"path":"2023/01/08/rotate-array/","link":"","permalink":"https://zielorem.github.io/2023/01/08/rotate-array/","excerpt":"","text":"Question 当前存在一个数组nums，编写算法将数组中的 个元素向右轮转 个位置（ 为非负数）。 为了避免直接轮转导致的数组元素覆盖，可以创建新的数组从而将中的元素存储至正确的位置，尔后再将其赋值至原数组中。在轮转过程中，当数组元素向右移动 个位置后，数组末端的 个元素将移动至数组首端，而剩余元素则向后移动 个位置。因此，可以通过翻转的方式将数组末端的元素移动至数组首端，而同时数组首端的元素将被翻转至数组末端。以数组[1, 2, 3, 4, 5, 6, 7]为例，其轮转过程为 将所有数组元素翻转 翻转区间内的元素 翻转区间内的元素 翻转操作本质上为互换操作。因此，需要定义一个临时变量temp用于替换操作。互换函数为 1234void swap(int* a, int* b){ int temp = *a; *a = *b, *b = t;} 持有互换函数后，需在翻转函数中确定互换的元素对象。翻转函数为 1234567void reverse(int* nums, int low, int high){ while(low &lt; high){ swap(&amp;nums[low], &amp;nums[high]); low++; high--; }} 因此，根据分析结果，轮转函数为 123456void rotate(int* nums, int numsSize, int k){ k %= numsSize; //避免k值大于数组长度 reverse(nums, 0, numsSize - 1); reverse(nums, 0, k - 1); reverse(nums, k, numsSize - 1);} 完整代码为 12345678910111213141516171819void swap(int* a, int* b){ int temp = *a; *a = *b, *b = t;}void reverse(int* nums, int low, int high){ while(low &lt; high){ swap(&amp;nums[low], &amp;nums[high]); low++; high--; }}void rotate(int* nums, int numsSize, int k){ k %= numsSize; reverse(nums, 0, numsSize - 1); reverse(nums, 0, k - 1); reverse(nums, k, numsSize - 1);} Python下该算法代码为 1234567class Solution(object): def rotate(self, nums, k): n = len(nums) k %= n nums[:] = nums[::-1] nums[:k] = nums[:k][::-1] nums[k:] = nums[k:][::-1] 更好的方法为通过slice操作拼接数组 123456class Solution(object): def rotate(self, nums, k): n = len(nums) k %= n nums[:] = nums[-k:] + nums[:-k]","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://zielorem.github.io/tags/algorithm/"}]},{"title":"利用双指针思想解决有序数组的平方排序问题","slug":"square-sort","date":"2023-01-08T03:42:16.000Z","updated":"2025-05-30T04:39:26.525Z","comments":true,"path":"2023/01/08/square-sort/","link":"","permalink":"https://zielorem.github.io/2023/01/08/square-sort/","excerpt":"","text":"Question 当前存在一个以非递减顺序排序的整数数组nums，编写算法返回每个数字的平方所组成的新数组，且同样按照非递减顺序排序。 本题最简单的思路即对每个数组元素均平方后的数组进行再排序，其时间复杂度为 。但由题意可知，有序数组最左端与最右端的元素在平方后均有可能成为最大数，因此可以考虑采用双指针法分别对数组中的负数与正数进行处理。 以数列[-7, -3, 2, 3, 11]为例，首先定义两个指针，其中负数指针low指向nums数组起始位置（即最小值位置），正数指针high指向nums数组末尾位置（即最大值位置）。再定义一个辅助新数组result生成的索引指针index，并指向result数组的末尾位置。 12int* result = malloc(sizeof(int) * numsSize);int low = 0, high = numsSize - 1, index = numsSize - 1; 当high所指元素的平方结果大于low所指元素的平方结果时，将high所指元素的平方结果导入result中index所指位置。同时，high左移至nums的下一位并准备与当前low所指元素进行比较，index左移至result的下一位。 123if(nums[low] * nums[low] &lt; nums[high] * nums[high]){ result[index--] = nums[high] * nums[high--];} 当low所指元素的平方结果大于high所指元素的平方结果时，将low所指元素的平方结果导入result中index所指位置。同时，low右移至nums的下一位并准备与当前high所指元素进行比较，index左移至result的下一位。 123if(nums[low] * nums[low] &gt; nums[high] * nums[high]){ result[index--] = nums[low] * nums[low++];} 故最终完整代码为 1234567891011121314int* sortedSquares(int* nums, int numsSize, int* returnSize){ int* result = malloc(sizeof(int) * numsSize); int low = 0, high = numsSize - 1, index = numsSize - 1; while(low &lt;= high){ if(nums[low] * nums[low] &lt; nums[high] * nums[high]){ result[index--] = nums[high] * nums[high--]; } else{ result[index--] = nums[low] * nums[low++]; } } *returnSize = numsSize; return result;} Python下代码为 123class Solution(object): def sortedSquares(self, nums): return sorted([i**2 for i in nums])","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://zielorem.github.io/tags/algorithm/"}]},{"title":"通过快慢指针法定位链表的中间结点","slug":"fast-slow","date":"2023-01-07T06:18:10.000Z","updated":"2025-05-30T04:39:27.860Z","comments":true,"path":"2023/01/07/fast-slow/","link":"","permalink":"https://zielorem.github.io/2023/01/07/fast-slow/","excerpt":"","text":"Question 给定一个头结点为head的非空单链表，返回链表的中间结点。若存在两个中间结点，则返回第二个中间结点。 链表的不足在于其无法通过下标直接访问特定结点，需要逐个遍历结点以定位特定结点。一般情况下，可以将链表中的数据内容逐个遍历至数组中，从而将链表转化为数组，进而直接输出数组下标为 的数组元素，但其代码比较繁杂。因此，本题采用更为巧妙的快慢指针法。 快慢指针法即同时设置一个快指针与一个慢指针对链表进行遍历，其中快指针一次遍历两个结点，慢指针一次遍历一个结点。当快指针最终指向链表末尾或NULL时，慢指针正好指向中间结点位置。 首先定义一个快指针与一个慢指针 12struct ListNode* slow = head;struct ListNode* fast = head; 在定义遍历循环前，需要首先确定循环终止条件。当结点数为奇数时，快指针最终会指向链表末尾，因此其循环为 1234while(fast-&gt;next != NULL){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next;} 当结点数为偶数时，慢指针最终会指向NULL，因此其循环为 1234while(fast != NULL){ fast = fast-&gt;next-&gt;next; slow = slow-&gt;next;} 故完整结构为 123456789101112131415161718/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */struct ListNode* middleNode(struct ListNode* head){ struct ListNode* fast = head; struct ListNode* slow = head; while(fast != NULL &amp;&amp; fast-&gt;next != NULL){ slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; } return slow;} Python下代码为 123456789101112131415# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def middleNode(self, head): fast = head slow = head while fast and fast.next: fast = fast.next.next slow = slow.next return slow","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://zielorem.github.io/tags/algorithm/"}]},{"title":"通过汉诺塔问题理解递归方法","slug":"hanoi-tower","date":"2023-01-06T15:11:42.000Z","updated":"2025-05-30T04:39:27.644Z","comments":true,"path":"2023/01/06/hanoi-tower/","link":"","permalink":"https://zielorem.github.io/2023/01/06/hanoi-tower/","excerpt":"","text":"Question 假设存在A、B、C三根杆，汉诺塔问题即需要将位置A上的圆盘全部移动至位置C，在移动过程中每次仅能移动一个圆盘，且三个位置上的圆盘状态始终保持为大盘在下、小盘在上。 假设目标汉诺塔为n阶，当n&#x3D;3时，其正常流程如下： 将小盘移动至位置C，将中盘移动至位置B 将小盘移动至位置B，将大盘移动至位置C 将小盘移动至位置A，将中盘移动至位置C 将小盘移动至位置C 从该过程中可以发现，汉诺塔问题的大致流程为 将位置A上除最大圆盘外的n-1个圆盘移动至位置B上 将最大圆盘移动至位置C上 将位置B上的剩余圆盘移动至位置C上 但由于在移动过程中每次仅能移动一个圆盘，因此步骤一的过程为（步骤三同理） 将位置A上第n-1个圆盘上的n-2个圆盘移动至位置C上 将第n-1个圆盘移动至位置B上 将位置C上的剩余圆盘移动至位置B上 因此，在解决n阶汉诺塔问题前，需要首先解决n-1阶汉诺塔问题。同理，在解决n-1阶汉诺塔问题前，需要首先解决n-2阶汉诺塔问题。如此持续进行会将问题最终转变为一阶汉诺塔问题，即 将某位置上的一个圆盘移动至另一个位置上 该操作实际为正常的移动圆盘操作。因此，n阶汉诺塔问题最终被逐渐降阶简化为基础的移动圆盘操作，该过程即计算机算法中的递归操作。 将移动一次圆盘的操作定义为函数move(n, a, b, c),其中n表示该次操作移动的圆盘数量，a表示起始位置，b表示过渡位置，c表示目标位置，则使用递归解决n阶汉诺塔问题的具体流程可用图表示为 当n&#x3D;3时，汉诺塔问题的最终流程可用图表示为 由上述流程可知，每阶汉诺塔问题均能使用同一流程解决。因此，函数move(n, a, b, c)具体内容为 12345678910void move(int n, char a, char b, char c)&#123; if(n == 1)&#123; printf(&quot;%c --&gt; %c&quot;, a, c); &#125; else&#123; move(n-1, a, c, b); move(1, a, b, c); move(n-1, b, a, c); &#125;&#125; 因此，使用递归解决汉诺塔问题的完整代码为 12345678910111213141516171819#include &lt;stdio.h&gt;void move(int n, char a, char b, char c)&#123; if(n == 1)&#123; printf(&quot;%c --&gt; %c&quot;, a, c); &#125; else&#123; move(n - 1, a, c, b); move(1, a, b, c); move(n - 1, b, a, c); &#125;&#125;int main()&#123; int n = 0; scanf(&quot;%d&quot;, &amp;n); move(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;); return 0;&#125; Python下算法代码为 12345678910def move(n, a, b, c): if n == 1: print(a, &quot;--&gt;&quot;, c) else: move(n - 1, a, c, b) move(1, a, b, c) move(n - 1, b, a, c)move(int(input()), &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://zielorem.github.io/tags/algorithm/"}]},{"title":"Python中的赋值、视图、副本与拷贝","slug":"view-and-copy","date":"2022-10-19T06:47:15.000Z","updated":"2025-05-30T04:39:26.536Z","comments":true,"path":"2022/10/19/view-and-copy/","link":"","permalink":"https://zielorem.github.io/2022/10/19/view-and-copy/","excerpt":"","text":"数组对象在创建后会存在唯一标识数组内容的通用标识符（即id值）与其数组内容在内存中的存储地址，通过不同方式创建基于原数组的新数组会在这两个属性的基础上产生不同的结果。 赋值与无拷贝将原数组直接赋值给新数组后，新数组同原数组的标识符与存储地址一致。因此，新数组可以粗略理解为完全通过原数组访问。因此在直接赋值过程中并未创建拷贝。 1234567891011a = np.array([[1, 2, 3], [3, 4, 5]])b = a # a直接赋值给bprint(id(a) == id(b)) # True，标识符一致print(a.data == b.data)# True，在物理内存中指向的存储地址一致print(a is b) # True，a与b实际上是同一个数组# 任一数组的变化会直接同步在其他数组上print(a.shape)b.shape = (3, 2)print(a.shape == b.shape) # True 视图与浅拷贝在numpy中对原数组(ndarray)进行切片操作或通过view()方法创建视图后，新数组同原数组的存储地址一致但标识符不一致。介于numpy在进行切片操作时直接操作了原数组，产生的新数组虽变更了标识符，但实际将原数组所在内存地址引用并赋值给了新数组，因此新数组仍基于原数组的存储地址进行内容访问。因此，修改新数组中的数据内容会直接影响并同步给原数组，但诸如变形之类的操作则不会。 12345678910111213141516a = np.array([[1, 2, 3], [3, 4, 5]])b = a[:] # 创建基于a的切片c = a.view() # 创建基于a的视图print(id(a) == id(b) == id(c)) # False，标识符不一致print(a.data == b.data == c.data)# True，在物理内存中指向的存储地址一致print(a is b is c) # False，a、b、c不是同一个数组# 对数组进行赋值操作会影响其他数组a[0, 2] = 4print(b[0, 2] == c[0, 2] == 4) # True# 对数组进行变形操作不会影响其他数组print(a.shape)b.shape = (3, 2)print(a.shape == b.shape) # False 副本与深拷贝对python序列(tuple)或列表(list)等对象进行切片操作、通过deepCopy()方法创建深拷贝或在numpy中通过copy()方法创建副本后，新数组同原数组的存储地址一致与标识符均不一致，两者之间相互独立。介于python进行切片操作时首先调用deepCopy()方法复制了原数组的深拷贝，然后再在该拷贝上进行操作，因此两者互不相关。 123456789a = [1, 2, 3, 4, 5]b = a[:] # 创建基于a的切片c = a.copy() # 创建基于a的副本print(id(a) == id(b) == id(c)) # False，标识符不一致print(a is b is c) # False，a、b、c不是同一个数组# 对数组进行操作不会影响其他数组a[2] = 4print(b[2] == 4 or c[2] == 4) # False python列表(list)对象进行append()操作时，实际进行了直接拷贝。 12345list1 = [1, 2]num = 3list1.append(num)print(list1)print(id(num) == id(list1[2])) # True 因此，若要避免因修改变量值导致的数组数据变化，可通过深拷贝解决。 12345list1 = [1, 2]num = 3list1.append(copy.deepcopy(num))print(list1)print(id(num) == id(list1[2])) # False 值得注意的是，numpy的ndarray对象进行append()操作需要将结果赋给其他的对象，因此经扩展后生成的新数组与原数组无关，所扩展的值与新数组中的对应扩展元素也无关。 1234list1 = np.array([1, 2])num = 3list2 = np.append(list1, num)print(id(num) == id(list2[2])) # False 总结 操作 拷贝类型 标识符 内存地址 直接赋值 无 一致 一致 numpy切片 浅拷贝 不同 一致 python切片 深拷贝 不同 不同 view()方法 浅拷贝 不同 一致 copy()方法 深拷贝 不同 不同","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"summary","slug":"summary","permalink":"https://zielorem.github.io/tags/summary/"}]},{"title":"Numpy库的主要使用方法","slug":"numpy","date":"2022-10-14T09:52:51.000Z","updated":"2025-05-30T04:39:28.292Z","comments":true,"path":"2022/10/14/numpy/","link":"","permalink":"https://zielorem.github.io/2022/10/14/numpy/","excerpt":"","text":"import numpy as np 数组属性 Numpy数组（即ndarray）的维度称为秩，一维数组的秩为 1，二维数组的秩为 2 每个线性的数组称为轴（即维度），二维数组相当于两个一维数组，而第一个一维数组中的每个元素又为一个一维数组 对于一维数组，ndarray.axis值仅为 0；对于二维数组，列轴（纵轴）的ndarray.axis值为 0，行轴（横轴）的ndarray.axis值为 1；对于三维数组，ndarray.axis的值为 0、1、2 时分别对应数组的第一维（第一层数组）、第二维（第二层数组）、第三维（第三层数组），第一层数组的元素是第二层数组，第二层数组的元素是第三层数组 属性 说明 ndarray.ndim 秩（维度或轴的数量） ndarray.shape 数组的维度（比如数组的n行m列） ndarray.size 数组元素总数 ndarray.axis 数组的轴 ndarray.dtype ndarray对象数据类型 ndarray.itemsize ndarray对象元素大小（byte） ndarray.flags ndarray对象内存信息 ndarray.real ndarray元素实部 ndarray.imag ndarray元素虚部 ndarray.data 实际数组元素缓冲区 dtypenumpy.dtype(&lt;object&gt;, &lt;align&gt;, &lt;copy&gt;) &lt;object&gt;为要转换为的数据类型对象 &lt;align&gt;若为True则填充字段使其类似于C的结构体 &lt;copy&gt;决定复制dtype对象，若为False则为对内置数据类型对象的引用 字节顺序通过对数据类型预先设定&gt;或&lt;决定，&gt;即大端法（高字节存储在最前的低位地址），&lt;即小端法 (低字节存储在最前的低位地址) 名称 描述 bool_ 布尔型数据类型（True或False） int_ 默认的整数类型（类似于C语言中的long，int32或int64） intc 与C语言中的int类型一致（一般是int32或int64） intp 用于索引的整数类型（类似于C语言中的ssize_t） int8 范围内的整数 int16 范围内的整数 int32 范围内的整数 int64 范围内的整数 uint8 范围内的无符号整数 uint16 范围内的无符号整数 uint32 范围内的无符号整数 uint64 范围内的无符号整数 float_ float64类型的简写 float16 半精度浮点数(包括1个符号位，5个指数位，10个尾数位) float32 单精度浮点数(包括1个符号位，8个指数位，23个尾数位) float64 双精度浮点数(包括1个符号位，11个指数位，52个尾数位) complex_ complex128类型的简写（即128位复数） complex64 复数，表示双32位浮点数（实数部分和虚数部分） complex128 复数，表示双64位浮点数（实数部分和虚数部分） 每个内建类型都有一个唯一定义它的字符代码 字符 对应类型 b 布尔型 i 整型（有符号） u 整型（无符号） f 浮点型 c 复数浮点型 m timedelta（时间间隔） M datetime（日期时间） O Python对象 S, a 字符串（byte-） U Unicode V 原始数据(void) 比如int8、int16、int32、int64四种数据类型可使用字符’i1’、’i2’、’i4’、’i8’代替 12data1 = np.dtype('i4') # 相当于int32data2 = np.dtype('&lt;i2') # 标注小端法 或通过dtype定义结构化数据类型（结构体） 123student = np.dtype([('name','S20'), ('age', 'i1'), ('grade', 'f4')]) data = np.array([('Alice', 21, 50),('Bob', 18, 75)], dtype = student) print(data) 切换ndarray中每个元素字节的大端与小端numpy.ndarray.byteswap(&lt;inplace&gt;) &lt;inplace&gt;默认为False，若为True则就地交换字节 12345a = np.array([8, 256, 16], dtype=np.int16)print(map(hex, a), end='\\n\\n') # &lt;map object at 0x7fcad80b4dc0&gt;print(a.byteswap(True), end='\\n\\n') # [2048, 1, 4096]print(map(hex, a)) # &lt;map object at 0x7fcae81ce890&gt; 创建数组numpy.array(&lt;object&gt;, &lt;dtype&gt;, &lt;copy&gt;, &lt;order&gt;, &lt;subok&gt;, &lt;ndmin&gt;) &lt;object&gt;为数组或嵌套的数列 &lt;dtype&gt;决定了数组元素的数据类型、数据大小、数据字节顺序等 &lt;order&gt;决定创建数组的样式，默认为 A（任意方向），同时 C 为行方向，F 为列方向 &lt;subok&gt;默认返回一个与基类类型一致的数组 &lt;ndmin&gt;指定生成数组的最小维度12arr1 = np.array([1,2,3]) # 一维数组arr2 = np.array([1,2,3],[4,5,6],[7,8,9]) # 二维数组 从已存在的数组创建新数组numpy.asarray(&lt;object&gt;, &lt;dtype&gt;, &lt;order&gt;) &lt;object&gt;为任意形式的输入参数（列表、元组、多维数组等） &lt;dtype&gt;决定返回数组的数据类型 &lt;order&gt;决定数据在计算机内存中存储元素的顺序，若为’C’则为行优先，为’F’则为列优先123x = [(1, 2, 3), (4, 5)]a = np.asarray(x, dtype = float)print(a) 接受buffer输入参数，以流的形式读入转化为ndarray对象，从而实现动态数组numpy.frombuffer(&lt;buffer&gt;, &lt;dtype&gt;, &lt;count&gt;, &lt;offset&gt;) &lt;buffer&gt;以流的形式读入，可以为任意对象 &lt;dtype&gt;决定返回数组的数据类型 &lt;count&gt;决定读取的数据数量，默认为 -1（读取所有数据） &lt;offset&gt;决定读取的起始位置，默认为 0 &lt;buffer&gt;为字符串时，Python3默认str为Unicode类型，需转为bytestring（即在原str前加b）123s = b'Kemono' # 转换为bytestringa = np.frombuffer(s, dtype = 'S1')print(a) 从可迭代对象中建立ndarray对象，返回一维数组numpy.fromiter(&lt;iterable&gt;, &lt;dtype&gt;, &lt;count&gt;) &lt;iterable&gt;为可迭代对象 &lt;dtype&gt;决定返回数组的数据类型 &lt;count&gt;决定读取的数据数量，默认为 -1（读取所有数据）12345list = range(5)it = iter(list) # 生成迭代器x = np.fromiter(it, dtype = float)print(x) 以指定数值范围创建数组numpy.arange(&lt;start&gt;, &lt;stop&gt;, &lt;step&gt;, &lt;dtype&gt;) &lt;start&gt;决定序列起始位（缺省为 0） &lt;stop&gt;决定序列终止位（不包含该位） &lt;step&gt;决定步长（缺省为 1） &lt;dtype&gt;决定返回数组的数据类型123arr1 = np.arange(5, dtype = float) # [0. 1. 2. 3. 4.]arr2 = np.arange(10, 20, 2) # [10 12 14 16 18]print(arr1, arr2) 创建一维等差数组np.linspace(&lt;start&gt;, &lt;stop&gt;, &lt;num&gt;, &lt;endpoint&gt;, &lt;retstep&gt;, &lt;dtype&gt;) &lt;start&gt;决定序列起始位 &lt;stop&gt;决定序列终止位 &lt;num&gt;决定生成的等步长的样本数量（缺省为 50） &lt;endpoint&gt;（默认）为True时，序列中包含&lt;stop&gt;值，反之不包含 &lt;retstep&gt;为True时，生成的数组中将显示间距，反之不显示 &lt;dtype&gt;决定返回数组的数据类型123a = np.linspace(1, 1, 10) # 十个1组成的序列b = np.linspace(10, 20, 5, endpoint = false, retstep = True)# [10., 12., 14., 16., 18.] 创建一维等比数组np.logspace(&lt;start&gt;, &lt;stop&gt;, &lt;num&gt;, &lt;endpoint&gt;, &lt;base&gt;, &lt;dtype&gt;) &lt;start&gt;决定序列起始位为base ** start &lt;stop&gt;决定序列终止位为base ** stop &lt;num&gt;决定生成的等步长的样本数量（缺省为 50） &lt;endpoint&gt;（默认）为True时，序列中包含&lt;stop&gt;值，反之不包含 &lt;base&gt;决定序列底数（缺省为 10） &lt;dtype&gt;决定返回数组的数据类型12a = np.logspace(1, 4, num = 4) # [10. 100. 1000. 10000.]b = np.logspace(0, 5, 5, endpoint = False, base = 2) # [1. 2. 4. 8. 16.] 创建一个指定形状与数据类型且未初始化的空数组numpy.empty(&lt;shape&gt;, &lt;dtype&gt;, &lt;order&gt;) &lt;shape&gt;为决定数组形状的整数或整数元组 &lt;dtype&gt;决定返回数组的数据类型 &lt;order&gt;决定数据在计算机内存中存储元素的顺序，若为’C’则为行优先，为’F’则为列优先 数组元素未初始化，因此内容为内存中的随机值 创建指定大小的以 0 或 1 填充的数组numpy.zeros(&lt;shape&gt;, &lt;dtype&gt;, &lt;order&gt;)numpy.ones(&lt;shape&gt;, &lt;dtype&gt;, &lt;order&gt;) &lt;shape&gt;为决定数组形状的整数或整数元组 &lt;dtype&gt;决定返回数组的数据类型，缺省为浮点数 &lt;order&gt;若为’C’则用于C的行数组，为’F’则用于FORTRAN的列数组123a = np.empty([3, 2], dtype = int) # 三行两列空二维数组b = np.zeros(2, 2) # 两行两列全零二维数组c = np.ones(2, 2) # 两行两列全一二维数组 创建以1填充对角线元素的二维等长数组（类似单位矩阵）np.eye(&lt;column&gt;, &lt;row&gt;, &lt;index&gt;, &lt;dtype&gt;) &lt;column&gt;决定二维数组行数 &lt;row&gt;决定二维数组列数（默认与行数一致） &lt;index&gt;决定对角线的索引 &lt;dtype&gt;决定数组返回元素的类型 创建对角数组np.diag(&lt;array_like&gt;, &lt;diagonal_position&gt;) &lt;array_like&gt;若为二维数组，则返回&lt;diagonal_position&gt;位置的对角线；若为一维数组，则返回一个&lt;array_like&gt;作为&lt;diagonal_position&gt;位置对角线的二维数组 &lt;diagonal_position&gt;决定对角线位置，若大于 0 则上移，反之下移123456x = np.eye(2) # 以1填充对角元素的二维两行两列数组y = np.arange(9).reshape((3, 3))arr1 = np.diag(y) # [0, 4, 8]arr2 = np.diag(y, -1) # [3, 7]z = np.diag(np.diag(arr1)) # 以[0, 4, 8]为对角元素的三行三列对角矩阵 给定形状的以随机样本 中的随机元素填充的数组np.random.rand(&lt;size&gt;) 给定形状的以服从标准正态分布的一个或一组元素填充的数组np.random.randn(&lt;size&gt;) 给定形状的以给定范围内的随机整数填充的数组np.random.randint(&lt;low&gt;, &lt;high&gt;, &lt;size&gt;, &lt;dtype&gt;) &lt;low&gt;决定起始位 &lt;high&gt;决定终止位（不包含），未赋值时整数范围为 &lt;size&gt;决定整数数组形状 &lt;dtype&gt;决定整数类型 给定形状的以 范围内的随机浮点数填充的数组np.random.random(&lt;size&gt;) 给定形状的以给定一维数组内的元素随机填充的数组np.random.choice(&lt;array&gt;, &lt;size&gt;, &lt;replace&gt;, &lt;p&gt;) &lt;array&gt;为给定的一维数组 &lt;size&gt;决定输出数组形状 &lt;replace&gt;决定一维数组中的元素可否被多次选中，默认为True &lt;p&gt;决定一维数组中各元素被选中的概率，形状必须与&lt;array&gt;一致 以seed值标记特定随机数序列np.random.seed(&lt;seed&gt;) 在相同seed值下所生成的随机数序列为同一批 调用其他方法生成随机数前，调用此方法可通过seed值标记特定随机数序列或采用已通过seed值标记的特定随机数序列 切片与索引通过内置的slice函数从原数组中切割出新数组slice(&lt;start&gt;, &lt;stop&gt;, &lt;step&gt;) &lt;start&gt;决定切割起始位 &lt;stop&gt;决定切割终止位 &lt;step&gt;决定切割间隔数值 Python切片时复制数组并操作，而Numpy切片时直接操作原数组 或通过冒号分割切片参数start:stop:step进行切片操作 切片可以通过省略号使得所选元组的长度与数组的维度相同，若在行位置使用省略号，其将返回包含行中元素的ndarray 1234567a = np.arange(10)s1 = slice(2, 7, 2) # 从索引2开始至索引7终止，间隔为2b = a[2:7:2] # a == bc = np.array([[1, 2, 3], [3, 4, 5], [4, 5, 6]])print(c[1,...]) # 第二行元素print(c[...,1:]) # 第二列及剩下所有列元素 返回数组中（沿特定轴）的最大元素与最小元素的索引值numpy.argmax(&lt;array&gt;, &lt;axis&gt;)numpy.argmin(&lt;array&gt;, &lt;axis&gt;) 返回数组中非零元素的索引值numpy.nonzero(&lt;array&gt;) 返回数组中满足给定条件的元素numpy.extract(&lt;condition&gt;) 返回数组中满足给定条件的元素的索引值numpy.where(&lt;condition&gt;) 123456a = np.array([[30, 40, 0], [0, 20, 10], [50, 0, 60]])print(np.nonzero(a)) # (array([0, 0, 1, 1, 2, 2]), array([0, 1, 1, 2, 0, 2]))print(np.where(a &gt; 35)) # (array([0, 2, 2]), array([1, 0, 2]))print(np.extract(np.mod(a, 3) == 0, a)) # [30, 0, 0, 0, 60] 整数数组索引可以借助切片:或...与索引数组组合 123456x = np.array([[1, 2, 3], [3, 4, 5], [5, 6, 7]])y = x[[0, 1, 2], [0, 1, 0]] #[1, 4, 5]a = x[1:3, 1:3] # [[4, 5], [6, 7]]b = x[1:3, [1, 2]] # a == bc = a[...,1:] # [[2, 3], [4, 5], [6, 7]] 布尔索引通过一个布尔数组索引目标数组布尔索引通过布尔运算获取符合指定条件的元素的数组 12x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]])print(x[x &gt; 5]) # [6, 7, 8, 9, 10, 11] 使用~(取补运算符)过滤NaN 12345a = np.array([np.nan, 1, 2, np.nan, 3, 4, 5])print(a[~np.isnan(a)]) # [1. 2. 3. 4. 5.]b = np.array([1, 2+6j, 5, 3.5+5j])print(a[np.iscomplex(a)]) # [2+6j, 3.5+5j] 存在多个条件时，将条件加以小括号或使用np.logical_and与np.all方法 12345x = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]])print(x[(x &gt; 5) &amp; (x &lt; 7)]) # 条件加小括号分割print(x[np.logical_and(x &gt; 5, x &lt; 7)]) # 使用np.logical方法print(x[np.all([x &gt; 5, x &lt; 7], axis=0)]) # 使用np.all方法 花式索引将整数数组的值作为目标数组的某轴下标进行索引对于使用一维整型数组作为索引： 若目标为一维数组，则索引结果为对应位置元素 若目标为二维数组，则索引结果为对应下标的行 将数据复制到新数组中12345x = np.arange(1, 9)a = x[[0, 6]] # [1, 7]y = np.arange(9).reshape((3, 3))b = x[[1, 0]] # [[3, 4, 5], [0, 1, 2]] 传入多个索引数组需使用np.ix_，即输入两个数组产生笛卡尔积的映射关系 12x = np.arange(9).reshape((3, 3))print(x[np.ix_([2, 1], [0, 2])]) # [[6, 8], [3, 5]] 广播对不同形状的数组进行数值计算的方式（即矩阵运算）若两个数组 x 与 y 形状相同，即x.shape == y.shape，则 a 与 b 相乘的结果为 a 与 b 数组对位相乘（维数相同且各维度长度相同） 1234a = np.array([1, 2, 3, 4])b = np.array([2, 3, 4, 5])c = a * bprint(c) # [2, 6, 12, 20] 若两个数组 x 与 y 形状不同，即x.shape != y.shape，则将触发广播机制 123a = np.array([[0, 0, 0], [10, 10, 10], [20, 20, 20], [30, 30, 30]])b = np.array([0, 1, 2])print(a + b) # [[0, 1, 2], [10, 11, 12], [20, 21, 22], [30, 31, 32]] 返回封装了一数组广播到另一数组的结果，并模仿广播对象numpy.broadcast(&lt;arr1&gt;, &lt;arr2&gt;) 将数组广播到新形状，并在原数组上返回只读视图，通常不连续numpy.broadcast_to(&lt;array&gt;, &lt;shape&gt;) &lt;array&gt;为原数组 &lt;shape&gt;为新形状 123456789101112131415x = np.arange(4, 7, 1, dtype=int)y = np.array([[1], [3], [5]])b = np.broadcast(x, y) # 返回广播对象row, column = b.iters # 两个flatiter对象# 广播的前两步对象print(next(row), next(column)) # (4, 1)print(next(row), next(column)) # (4, 3)print('\\n')c = np.empty(b.shape) #3 *3大小的空数组c.flat = [i + j for (i,j) in b] # [[5, 7, 9], [6, 8, 10], [7, 9, 11]]print(np.broadcast_to(x, (2, 3))) # [[4, 5, 6], [4, 5, 6]] 迭代器提供灵活访问一个或多个数组元素的方法，迭代选择顺序与数据内存布局一致，缺省行序优先np.nditer(&lt;array_like&gt;, &lt;flags&gt;, &lt;op_flags&gt;, &lt;order&gt;) &lt;array_like&gt;为需要迭代的序列 &lt;flags&gt;用于控制迭代器行为 属性 说明 buffered 在需要时启用缓冲 c_index 跟踪C顺序索引 f_index 跟踪Fortran顺序索引 multi_index 跟踪多个索引或每次迭代跟踪一种索引(多维索引) external_loop 所给值为具有多个值的一维数组而非零维数组 &lt;op_flags&gt;指定每个操作的特征，缺省状态下待迭代数组状态为’read-only’，若在遍历迭代数组的同时修改数组元素则需指定为’readwrite’或’writeonly’ &lt;order&gt;用于控制迭代顺序，’C’为行序优先，’F’为列序优先1234567891011121314151617181920212223242526272829303132a = np.arange(6).reshape(2, 3)# 迭代输出数组元素for x in np.nditer(a): print(x, end = ', ')print('\\n') # [0, 1, 2, 3, 4, 5,]# 迭代输出转置数组元素for y in np.nditer(a.T): print(y, end = ', ')print('\\n') # [0, 1, 2, 3, 4, 5,]# y在转置后元素在内存中的存储顺序仍与x一致# 以行序优先模式迭代输出转置数组的元素for z in np.nditer(a.T, order = 'C'): print(z, end = ', ')print('\\n') # [0, 3, 1, 4, 2, 5,]# 修改数组元素for x in np.nditer(a, op_flags='readwrite'): x[...] = 2*xprint(x) # [0, 2, 4, 6, 8, 10,]# 添加索引it = np.nditer(x, flags=['multi_index'])while not it.finished: print(\"%d&lt;%s&gt;\"%(it[0], it.multi_index)) #生成二维index it.iternext() # 进入下一次迭代# 添加外部循环(对应于每列并组合为一维数组)for x in np.nditer(x, flags=['external_loop'], order='F'): print(x, end=', ') #[[0, 2], [4, 6], [8, 10]] nditer可同时迭代两个可广播数组 12345a = np.array([1, 2, 3, 4], dtype=int)b = np.arange(0, 60, 5).reshape(3, 4)for x,y in np.nditer([a,b]): print('%d:%d' % (x,y), end=', ') # 1:0, 2:5, 3:10, 4:15, 1:20, 2:25, 3:30, 4:35, 1:40, 2:45, 3:50, 4:55 数组操作在不改变原始数据的情况下修改数组形状numpy.reshape(&lt;array&gt;, &lt;newshape&gt;, &lt;order&gt;) &lt;array&gt;为需要修改形状的数组 &lt;newshape&gt;为整数或整数数组（应兼容原数组形状） &lt;order&gt;决定元素的排列顺序 属性 说明 ‘C’ 按行排列 ‘F’ 按列排列 ‘A’ 按数组原顺序排列 ‘K’ 按元素在内存中的存储顺序排列 对数组中各元素进行处理（数组元素迭代器）numpy.ndarray.flat() 返回一份展开的数组拷贝并独立于原数组numpy.ndarray.flatten(&lt;order&gt;) &lt;order&gt;决定元素的排列顺序（同reshape()） 对拷贝所进行的修改不会影响原数组 返回一份展开的数组视图numpy.ravel(&lt;array&gt;, &lt;order&gt;) &lt;array&gt;为需要进行操作的数组 &lt;order&gt;决定元素的排列顺序（同reshape()） 对视图进行的修改会影响原数组123456789a = np.arange(9).reshape(3, 3)for elements in a.flat: print(element) #依次输出数组中元素# 按列优先顺序展开数组print(a.flatten(order='F'), end=', ') # [0, 3, 6, 1, 4, 7, 2, 5, 8, ]# 以行优先顺序展开数组print(a.ravel(order='C'), end=', ') # [0, 1, 2, 3, 4, 5, 6, 7, 8, ] 对换数组维度（转置）numpy.transpose(&lt;array&gt;, &lt;axes&gt;) &lt;array&gt;为需要对换数组维度的数组 &lt;axes&gt;为对应维度的整数列表（通常对换所有维度） 类似于numpy.ndarray.T 向后滚动特定数组坐标轴numpy.rollaxis(&lt;array&gt;, &lt;axis&gt;, &lt;start&gt;) &lt;array&gt;为需要对坐标轴执行向后滚动操作的数组 &lt;axis&gt;为需要向后滚动的轴 &lt;start&gt;表示需要滚动至的特定位置，缺省为 0（第 0 个轴） 其他轴的相对位置不会改变 对换数组的两个坐标轴numpy.swapaxes(&lt;array&gt;, &lt;axis1&gt;, &lt;axis2&gt;) &lt;array&gt;为需要执行对换坐标轴操作的数组 &lt;axis1&gt;、&lt;axis2&gt;为对应两个轴的整数序号 123a = np.arange(8).reshape(2, 2, 2)b = np.rollaxis(a, 2, 0) # 轴2（宽度）滚动至轴0（深度）的位置c = np.swapaxes(a, 2, 0) # 轴2（宽度）与轴0（深度）互换位置 在指定位置插入新轴以扩展数组numpy.expand_dims(&lt;array&gt;, &lt;axis&gt;) &lt;array&gt;为执行数组 &lt;axis&gt;为新轴所插入位置 在指定数组中删除值为1的维度numpy.squeeze(&lt;array&gt;, &lt;axis&gt;) &lt;array&gt;为执行数组 &lt;axis&gt;用于指定需要删除的维度（单维度），取值为None、int或tuple of ints，取值为空时删除所有值为 1 的维度（单维度） 12345678x = np.arange(4, 7, 1, dtype=int)y = np.array([[1], [3], [5]])z = np.expand_dims(y, axis=1) # 在位置1插入新轴print(z.shape) # (3, 1, 1)z = np.squeeze(z，axis=(2,))print(z.shape) # (3, 1) 沿指定轴连接相同形状的两个或多个数组numpy.concatenate(&lt;arrays&gt;, &lt;axis&gt;) &lt;arrays&gt;为同类型同形状的数组 &lt;axis&gt;指定连接数组的轴（缺省为 0，上下连接），若值为 1 则左右连接 沿新轴合并一系列数组numpy.stack(&lt;arrays&gt;, &lt;axis&gt;) &lt;arrays&gt;为同类型同形状的数组 &lt;axis&gt;指定数组序列的堆叠方向 axis值 说明 axis=0 在最外层括号执行堆叠 axis=1 在次外层括号执行堆叠 axis=2 (三维数组中)在最内层括号内执行堆叠 堆叠后的数组比原数组多一个维度 通过水平堆叠生成数组numpy.hstack(&lt;arrays&gt;) &lt;arrays&gt;为同类型同形状的数组 相当于numpy.concatenate()方法中&lt;axis&gt;值为 1 通过垂直堆叠生成数组numpy.vstack(&lt;arrays&gt;) &lt;arrays&gt;为同类型同形状的数组 相当于numpy.concatenate()方法中&lt;axis&gt;值为 0 123456789101112131415a = np.array([[1, 2], [3, 4]])b = np.array([[4, 3], [2, 1]])# 沿轴1连接数组a与数组bprint(np.concatenate((a, b), axis=1), end='\\n\\n')print(np.hstack((a, b)), end='\\n\\n')# [[1, 2, 4, 3], [3, 4, 2, 1]]print(np.concatenate((a, b), axis=0), end='\\n\\n')print(np.vstack((a, b)), end='\\n\\n')# [[1, 2], [3, 4], [4, 3], [2, 1]]c = np.stack((a, b), axis=0) # [[[1, 2], [3, 4]], [[4, 3], [2, 1]]]print(np.stack((a, b), axis=1)) # [[[1, 2], [4, 3]], [[3, 4], [2, 1]]]print(np.stack(c, axis=2)) # [[[1, 4], [2, 3]], [[3, 2], [4, 1]]] 沿特定轴分割数组numpy.split(&lt;array&gt;, &lt;indices_or_sections&gt;, &lt;axis&gt;) &lt;arrays&gt;为被分割的数组 &lt;indices_or_sections&gt;若为整数则将数组均分为该数等份，若为数组则决定沿轴分割位置 &lt;axis&gt;决定数组沿着何方向分割，缺省为 0（横向分割），为 1 时纵向分割 纵向分割数组numpy.hsplit(&lt;array&gt;, &lt;indices_or_sections&gt;) &lt;arrays&gt;为被分割的数组 &lt;indices_or_sections&gt;若为整数则将数组均分为该数等份，若为数组则决定沿轴分割位置 相当于numpy.split()方法中&lt;axis&gt;值为 1 横向分割数组numpy.vsplit(&lt;array&gt;, &lt;indices_or_sections&gt;) &lt;arrays&gt;为被分割的数组 &lt;indices_or_sections&gt;若为整数则将数组均分为该数等份，若为数组则决定沿轴分割位置 相当于numpy.split()方法中&lt;axis&gt;值为 01234567891011a = np.arange(6)b = np.split(a, 3)c = np.split(a, [2, 4])# [0, 1], [2, 3], [4, 5]x = np.arange(9).reshape(3, 3)y1 = np.split(x, 3, 1)y2 = np.hsplit(x, [1, 2])# [[0], [3], [6]], [[1], [4], [7]], [[2], [5], [8]] 返回指定大小的新数组numpy.resize(&lt;array&gt;, &lt;shape&gt;) &lt;arrays&gt;为需要修改大小的数组 &lt;shape&gt;为数组返回的新形状 分配整个数组并在数组的末尾追加值（扩展数组）numpy.append(&lt;array&gt;, &lt;values&gt;, &lt;axis&gt;) &lt;arrays&gt;为需要扩展的数组 &lt;values&gt;为需要向数组扩展的数组内容（与原数组形状相同） &lt;axis&gt;指定数组扩展方向，默认为None并返回一维数组。若定义值为 0 则纵向扩展（列数需一致），定义值为 1 则横向扩展（行数需一致） 在指定索引前沿指定轴在数组中插入值numpy.insert(&lt;array&gt;, &lt;index&gt;, &lt;values&gt;, &lt;axis&gt;) &lt;arrays&gt;为需要插入值的数组 &lt;index&gt;为插入位置的索引 &lt;values&gt;为需要插入的值 &lt;axis&gt;为插入位置所沿的轴，默认展开原数组。若定义值为 0 则横向插入，定义值为 1 则纵向插入 在指定索引沿指定轴在数组中删除指定子数组numpy.delete(&lt;array&gt;, &lt;index&gt;, &lt;axis&gt;) &lt;arrays&gt;为需要删除值的数组 &lt;index&gt;为删除位置的索引 &lt;axis&gt;为删除位置所沿的轴，默认展开原数组。若定义值为 0 则横向删除，定义值为 1 则纵向删除 删除数组中重复元素numpy.unique(&lt;array&gt;, &lt;return_index&gt;, &lt;return_inverse&gt;, &lt;return_counts&gt;) &lt;arrays&gt;为需要去重的数组 &lt;return_index&gt;若为True，则返回去重后数组内元素在原数组中的索引位置（列表形式） &lt;return_inverse&gt;若为True，则返回原数组内元素在去重后数组中的索引位置（列表形式） &lt;return_counts&gt;若为True，则返回原数组内各元素出现次数123456789101112131415a = np.array([[1, 2, 3], [4, 5, 6]])b1 = np.resize(a, (3, 2)) # [[1, 2], [3, 4], [5, 6]]b2 = np.resize(a, (3, 3)) # [[1, 2, 3], [4, 5, 6], [1, 2, 3]]c1 = np.insert(a, 3, [3, 4]) # [1, 2, 3, 3, 4, 4, 5, 6]c2 = np.insert(a, 2, [7, 8, 9], axis=0) # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]c3 = np.insert(a, [1, 2], [9], axis=1) # [[1, 9, 2, 9, 3], [4, 9, 5, 9, 6]]d1 = np.delete(c3, [1, 3], axis=1) #[[1, 2, 3], [4, 5, 6]]d2 = np.delete(a, np.s_[::2]) #[2, 4, 6]e, indices = np.unique(c1, return_index=True)print(e) # [1, 2, 3, 4, 5, 6]print(indices) # [0, 1, 2, 4, 5, 6, 7] 位运算对数组中整数元素的二进制形式执行位运算 运算方法 说明 numpy.bitwise_and(&lt;numbers&gt;) 位与运算 numpy.bitwise_or(&lt;numbers&gt;) 位或运算 numpy.invert(&lt;number&gt;) 取反运算 将数组中元素的二进制形式左移指定位置，右侧补上相应数量的 0numpy.left_shift(&lt;number&gt;，&lt;movement&gt;) &lt;number&gt;为数组中元素 &lt;movement&gt;为数组左移位数 将数组中元素的二进制形式右移指定位置，左侧补上相应数量的 0numpy.right_shift(&lt;number&gt;，&lt;movement&gt;) &lt;number&gt;为数组中元素 &lt;movement&gt;为数组右移位数 123456789101112131415161718print(np.bitwise_and(21, 25))# 0b10101 + 0b11001 == 0b10001 (17)print(np.bitwise_or(21, 25))# 0b10101 + 0b11001 == 0b11101 (29)print(np.invert(7))# 原码转二进制 0b00000111# 按位取反 0b11111000# 首位为1表示负数，将除符号位外的其他位取反 0b10000111# (末位加1)取补码 0b10001000# 转回十进制 -8print(np.left_shift(7, 3))# 0b00000111 --&gt; 0b00111000 (56)print(np.right_shift(56, 3))# 0b00111000 --&gt; 0b00000111 (7) 字符串 方法 说明 numpy.char.add(&lt;strings&gt;) 连接两个字符串元素 numpy.char.multiply(&lt;string&gt;) 复制某个指定字符串元素并连接（多重连接） numpy.char.center(&lt;strings&gt;, &lt;length&gt;, &lt;fillchar&gt;) 将字符串居中，并指定一个字符在左右两侧填充 numpy.char.capitalize(&lt;strings&gt;) 将字符串的首字母转换为大写 numpy.char.title(&lt;strings&gt;) 将字符串的每个单词的首字母均转换为大写 numpy.char.upper(&lt;strings&gt;) 将字符串的每个元素转换为大写 numpy.char.lower(&lt;strings&gt;) 将字符串的每个元素转换为小写 numpy.char.split([&lt;strings&gt;], [&lt;seperates&gt;]) 指定分隔符（默认空格）分割字符串，并返回数组 numpy.char.splitlines(&lt;strings&gt;) 将换行符作为分隔符以分割字符串，并返回数组 numpy.char.strip([&lt;strings&gt;], &lt;char_to_delete&gt;) 移除开头处与结尾处的某个指定字符 numpy.char.join([&lt;fill_chars&gt;], [&lt;strings&gt;]) 指定分隔符填充字符串中字符间的间隔 numpy.char.replace(&lt;strings&gt;, &lt;string_to_replace&gt;, &lt;replacement&gt;) 使用一个新字符串替换一个指定的原字符串中的所有子字符串 numpy.char.encode(&lt;strings&gt;, &lt;encoder&gt;) 对元素进行编码（默认编码为 uft-8 ） numpy.char.encode(&lt;strings&gt;, &lt;decoder&gt;) 对元素进行解码（默认解码为 uft-8 ） 数学 方法 说明 numpy.add() 加法 numpy.subtract() 减法 numpy.multiply() 乘法 numpy.divide() 除法 numpy.reciprocal() 取倒数 numpy.power() 取幂 numpy.mod() 取余 numpy.dot() 数组点积 numpy.vdot() 向量点积 numpy.inner() 数组内积 numpy.matmul() 矩阵积 numpy.sin() 正弦函数 numpy.cos() 余弦函数 numpy.tan() 正切函数 numpy.arctan() 反正弦函数 numpy.arccos() 反余弦函数 numpy.arctan() 反正切函数 numpy.degrees() 弧度转角度 numpy.around(&lt;number&gt;, &lt;decimals&gt;) 四舍五入 numpy.floor() 向下取整 numpy.ceil() 向上取整 &lt;decimals&gt;指定舍入的小数位数，缺省为 0 ，若为负数则将整数四舍五入至小数点左侧 执行运算前各运算元素须具有相同形状或符合数组广播规则 两个数组的点积numpy.dot(&lt;ndarrays&gt;, &lt;out&gt;) &lt;ndarrays&gt;若为一维数组，结果为两数组的内积；若为二维数组，结果为两数组的矩阵乘积；若为多维数组，结果为数组最后一维上所有元素与另一数组倒数第二维上所有元素的乘积之和 &lt;out&gt;存储计算结果 两个向量的点积numpy.vdot(&lt;ndarrays&gt;) &lt;ndarrays&gt;中第一个参数若为复数，则其共轭复数会被用于计算；若为多维数组，则会被展开 一维数组的向量内积numpy.inner(&lt;ndarrays&gt;) &lt;ndarrays&gt;若维度大于 1 ，则返回沿最后一个轴的矩阵乘积 两个数组的矩阵乘积numpy.matmul(&lt;ndarrays&gt;) &lt;ndarrays&gt;若为二维数组，则结果为矩阵乘法；若任意数组的维数大于 2 ，则将其视作存在于最后两个索引的矩阵的栈，并进行相应广播；若任意数组为一维数组，则将其维度加 1 变为矩阵，乘法结束后去除 1234567891011x = np.array([[1, 2], [3, 4]])y = np.array([[5, 6], [7, 8]])print(np.dot(x, y)) # [[19, 22], [43, 50]](矩阵乘积)print(np.vdot(x, y)) # 70（矩阵内积）print(np.inner(x, y)) # [[17, 23], [39, 53]]a = np.array([1+2j, 3+4j])b = np.array([5+6j, 7+8j])print(np.vdot(a, b)) # (70-8j)print(np.vdot(b, a)) # (70+8j) 计算输入矩阵的行列式的值numpy.linalg.det(&lt;ndarrays&gt;) 计算矩阵形式的线性方程的解numpy.linalg.solve(&lt;ndarray_formula&gt;, &lt;ndarray_result&gt;) &lt;ndarray_formula&gt;为线性方程未知数部分的参数 &lt;ndarray_result&gt;为线性方程组结果 计算矩阵的逆矩阵numpy.linalg.inv(&lt;ndarray&gt;) 123456789a = np.array([[4, 3], [2, 1]])b = np.array([2, 4])print(np.linalg.det(a)) # -2.0#计算线性方程组 4x+3y=2, 2x+y=4 的结果print(np.linalg.solve(a, b)) #[5, -6](x==5, y==-6)c = np.linalg.inv(a) # [[-0.5, 1.5], [ 1., -2.]]print(np.dot(a, c)) # [[1., 0.], [0., 1.]] 统计 方法 说明 numpy.amin(&lt;array&gt;, &lt;axis&gt;) 数组元素沿指定轴的最小值 numpy.amax(&lt;array&gt;, &lt;axis&gt;) 数组元素沿指定轴的最大值 numpy.ptp(&lt;array&gt;, &lt;axis&gt;) 数组沿指定轴的极差 numpy.percentile(&lt;array&gt;, &lt;percentage&gt;, &lt;axis&gt;) 数组指定百分位沿指定轴的分位数 numpy.median(&lt;array&gt;, &lt;axis&gt;) 数组沿指定轴的中位数 numpy.mean(&lt;array&gt;, &lt;axis&gt;) 数组沿指定轴的平均数 numpy.average(&lt;array&gt;, &lt;weight&gt;, &lt;axis&gt;) 根据另一数组中所给权重计算数组中元素的加权平均值 numpy.std(&lt;array&gt;, &lt;axis&gt;) 数组沿指定轴的标准差 numpy.var(&lt;array&gt;, &lt;axis&gt;) 数组沿指定轴的方差 numpy.average()方法在不给定&lt;weight&gt;时相当于numpy.mean()方法， 在未指定&lt;axis&gt;时上述方法将展开数组 排序返回数组排序后的副本numpy.sort(&lt;array&gt;, &lt;axis&gt;, &lt;sort_approach&gt;, &lt;order&gt;) &lt;array&gt;为需要排序的数组 &lt;axis&gt;指定排序所沿的轴 &lt;kind&gt;指定排序方法 方法 说明 'quicksort' 快速排序 'mergesort' 归并排序 'heapsort' 堆排序 &lt;order&gt;指定所排序的字段 返回数组内从小到大的数组值的索引值numpy.argsort(&lt;array&gt;, &lt;axis&gt;) 同时对多个序列排序并返回排序结果中各元素在原数组中对应的索引值numpy.lexsort(&lt;arrays&gt;) 沿列排序numpy.msort(&lt;array&gt;) 相当于np.sort()方法中&lt;axis&gt;值为 0 以先实部后虚部的顺序对复数排序numpy.sort_complex(&lt;array&gt;) 12345678910111213data = np.dtype([('name', 'S10'), ('age', int)])stu = np.array([('Dylan', 17), ('Alice', 16), ('Frank', 18)], dtype=data)print(np.sort(stu, order='age')) #按age排序x = np.array([5, 2, 7])y = np.argsort(x)print(x[y]) # 重构数组name = [['Dylan'], ['Alice'], ['Frank']]cls = [['A'], ['B'], ['A']]print(np.lexsort((cls, name)), end='\\n\\n') #排序索引结果print([name[i] + ',' + cls[i] for i in cls]) #排序结果 挑选指定数组中最小的几个元素置于数组最前端，并与其他元素分为两堆numpy.partition(&lt;array&gt;, &lt;kth&gt;, &lt;axis&gt;) 新数组中前&lt;count&gt;个元素为原数组中最小的&lt;count&gt;个元素 仅将最小的&lt;count&gt;个元素置于数组最前端，不需要完整排序（类似快速排序过程） 返回分区后的新数组 挑选指定数组中最小的几个元素置于数组最前端，并与其他元素分为两堆numpy.argpartition(&lt;array&gt;, &lt;kth&gt;, &lt;axis&gt;) 与numpy.partition()的主要功能相同 返回分区后的新数组内元素在原数组中的索引号 123456789101112arr = np.array([4, 5, 7, 1, 9, -4, -3, -6, -1])print(np.partition(arr, kth=4)) # [-6, -4, -3, -1, 1, 4, 7, 5, 9]# 返回数组中最小的3个数字print(np.partition(arr, kth=3)[:3], end='\\n\\n')print(arr[np.argpartition(arr, kth=3)[:3]])# [-6, -4, -3]# 返回数组中最大的5个数字print(np.partition(arr, kth=-5)[-5:], end='\\n\\n')print(arr[np.argpartition(arr, kth=-5)[-5:]])# [1, 4, 7, 5, 9] 文件将数组保存到以 .npy 为扩展名的文件中numpy.save(&lt;fname&gt;, &lt;array&gt;, &lt;allow_pickle&gt;, &lt;fix_imports&gt;) &lt;fname&gt;为需要保存的文件名 &lt;array&gt;为需要保存的数组 &lt;allow_pickle&gt;允许使用Python pickles保存对象数组，Python中的pickle用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化，默认为False &lt;fix_imports&gt;方便从Pyhton2中读取Python3中保存的数据，默认为True 读取 .npy 文件 numpy.load(&lt;fname&gt;, &lt;allow_pickle&gt;, &lt;fix_imports&gt;) &lt;fname&gt;为需要保存的文件名 &lt;allow_pickle&gt;允许使用Python pickles读取对象数组，默认为False &lt;fix_imports&gt;方便从Python2中读取Python3中保存的数据，默认为True 将多个数组保存到以 .npz 为扩展名的文件中numpy.savez(&lt;fname&gt;, *args, **kwds) &lt;fname&gt;为需要保存的文件名 *args为需要保存的数组，可以使用关键字参数为数组命名，否则数组会自动命名为 arr_0, arr_1, … **kwds为需要保存的数组使用的关键字名称 以简单的文本文件格式存储数据np.savetxt(&lt;fname&gt;, &lt;array&gt;, &lt;fmt&gt;, &lt;delimiter&gt;) &lt;fname&gt;为需要保存的文件名 &lt;array&gt;为需要保存的数组 &lt;fmt&gt;指定存储数据类型，默认为’%.18e’ &lt;delimiter&gt;指定元素之间的分隔符，默认为空格 读取 .txt 文件np.loadtxt(&lt;fname&gt;, &lt;dtype&gt;, &lt;delimiter&gt;) &lt;fname&gt;为需要读取的文件名 &lt;dtype&gt;指定读取所返回的数据类型，默认为float &lt;delimiter&gt;指定读取的分隔符，默认无分隔符 矩阵自 1.19.0 版本后Numpy官方已不推荐引用numpy.matlib方法，同时不推荐通过矩阵类表示矩阵或处理线性代数问题(见 https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users) ，建议使用常规Ndarray类。","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"summary","slug":"summary","permalink":"https://zielorem.github.io/tags/summary/"}]},{"title":"Pandas库的主要使用方法","slug":"pandas","date":"2022-10-11T06:37:29.000Z","updated":"2025-05-30T04:39:27.096Z","comments":true,"path":"2022/10/11/pandas/","link":"","permalink":"https://zielorem.github.io/2022/10/11/pandas/","excerpt":"","text":"import pandas as pd SeriesSeries由index和列组成，类似于一维数组（或数据库中的id与数据实体）pandas.Series(&lt;data&gt;, &lt;index&gt;, &lt;dtype&gt;, &lt;series_name&gt;, &lt;copy&gt;) &lt;data&gt;为list、tuple、dict等ndarray类型 &lt;index&gt;为数据索引标签，默认从 0 开始 &lt;dtype&gt;为所存储数据类型（默认自动判断） &lt;name&gt;为Series名称 &lt;copy&gt;为拷贝数据，缺省为False ‘Series’首字母要大写123456a = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]myvar = pd.Series(a)print(myvar)print(myvar[2]) # 根据索引值读取数据myvar = pd.Series(a, index=[&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]) # 也可指定索引值 通过dict创建Series，字典的key会变为series的索引值 123456789name = &#123;1: &quot;Alice&quot;, 2: &quot;Bob&quot;, 3: &quot;Cindy&quot;&#125;myvar = pd.Series(name)print(myvar)# 若仅需dict中的部分数据，仅需指定所需数据的索引即可myvar = pd.Series(name, index=[1, 2])# 设置Series名称myvar = pd.Series(myvar, name=&#x27;Series_test&#x27;) DataFrame DataFrame为二维表格型数据结构（存在行索引与列索引），类似于二维数组 其含有一组有序的列，每列数据类型可不同 类似于由一组Series组成的dict pandas.DataFrame(&lt;data&gt;, &lt;index&gt;, &lt;columns&gt;, &lt;dtype&gt;, &lt;copy&gt;) &lt;data&gt;为list、tuple、dict等ndarray类型 &lt;index&gt;为数据索引标签（或行标签） &lt;columns&gt;为列标签，缺省为 RangeIndex(0, 1, 2, …, n) &lt;dtype&gt;为所存储数据类型（默认自动判断） &lt;copy&gt;为拷贝数据，缺省为False123data = [[&#x27;Alice&#x27;, 10], [&#x27;Bob&#x27;, 12], [&#x27;Cindy&#x27;, 13]]df = pd.DataFrame(data, columns=[&#x27;Name&#x27;, &#x27;Age&#x27;]) #或index=[&#x27;stu1&#x27;, &#x27;stu2&#x27;]print(df) 使用dict配合ndarrays创建DataFrame 123data = &#123;&#x27;Name&#x27;:[&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Cindy&#x27;], &#x27;Age&#x27;:[10, 12, 13]&#125;df = pd.DataFrame(data)print(df) ndarrays的长度需相同 若传递了&lt;index&gt;，则&lt;index&gt;的长度应等于ndarray的长度 若未传递&lt;index&gt;，则缺省下索引为range(n)，其中 n 为ndarray长度 使用dict(key&#x2F;value)创建DataFrame，其中dict的key为列名 123data = [&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;, &#123;&#x27;a&#x27;: 5, &#x27;b&#x27;: 10, &#x27;c&#x27;: 20&#125;]df = pd.DataFrame(data)print(df) 可使用loc属性返回指定行的数据，缺省下第一行索引为 0比如第一行为df.loc[0]或df.loc[&#39;stu1&#39;]第一行及第二行为df.loc[[0, 1]]或df.loc[[&#39;stu1&#39;, &#39;stu2&#39;]]返回结果为一个Series数据 .csv通过read_csv()将.csv文件转储为DataFrame数据 12df = pd.read_csv(&#x27;example.csv&#x27;)print(df.to_string()) #to_string()返回DataFrame数据，否则仅输出前五行与后五行 或通过to_csv()将DataFrame数据转储为.csv文件 123456789101112#三个字段name, age, gendername = [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Cindy&#x27;]age = [10, 12, 13]gender = [&#x27;F&#x27;, &#x27;M&#x27;, &#x27;F&#x27;]#字典dict = &#123;&#x27;name&#x27;: name, &#x27;age&#x27;: age, &#x27;gender&#x27;: gender&#125;df = pd.DataFrame(dict)#保存df.to_csv(&#x27;stu.csv&#x27;) 通过head(n)方法读取前n行（缺省前五行） 通过tail(n)方法读取后n行（缺省后五行） 通过info()方法返回.csv文件基本信息（如行数、列数、各列数据类型等）123print(df.head()) #前五行print(df.tail(7)) #后七行print(df.info()) #.csv信息 数据处理统计计算 使用mean()方法计算列的均值 使用median()方法计算列的中位数 使用mode()方法计算列的众数 1234df = pd.read_csv(&#x27;stu.csv&#x27;)avg = df[&#x27;grade&#x27;].mean() #计算grade列的平均数mid = df[&#x27;grade&#x27;].median() #计算grade列的中位数mod = df[&#x27;grade&#x27;].mode() #计算grade列的众数 去除空值DataFrame.dropna(&lt;axis&gt;, &lt;how&gt;, &lt;thresh&gt;, &lt;subset&gt;, &lt;inplace&gt;) &lt;axis&gt;默认为 0，即逢空值剔除整行，若设置为 1 则表示逢空值剔除整列 &lt;how&gt;默认为’any’，即一行（或一列）中任何数据为空则剔除整行（或整列），若设置为’all’则仅当一行（或一列）中任何数据均为空时才剔除整行（或整列） &lt;thresh&gt;设置保留整行（或整列）所需的非空值的数量阈值 &lt;subset&gt;设置需要检查的列 &lt;inplace&gt;默认为False，即返回一个新的DataFrame，不会修改原数据。若设置为True，则将计算得到的值覆盖原数据并返回None 通过isnull()方法判断列（或行）中各单元格是否为空 通过na_values指定空数据类型 通过fillna指定特定值替换空字段 12345678910missing_values = [&#x27;n/a&#x27;, &#x27;na&#x27;, &#x27;--&#x27;] #指定空数据范例df = pd.read_csv(&#x27;stu.csv&#x27;, na_values = missing_values)print(df[&#x27;city&#x27;].isnull())new_df = df.dropna(subset=[&#x27;city&#x27;]) #剔除city列中字段值为空的行print(new_df.to_string()) #输出新DataFrame#指定city列中使用&#x27;null_city&#x27;替换空字段df[&#x27;city&#x27;].fillna(&#x27;null_city&#x27;, inplace=True) print(df.to_string()) 去除格式错误数据将列中单元格统一转换为相同格式的数据 12345678910#第三个日期格式错误data = &#123; &#x27;Date&#x27;: [&#x27;2022/12/01&#x27;, &#x27;2022/12/02&#x27;, &#x27;20221203&#x27;], &#x27;Count&#x27;: [50, 40, 30]&#125;df = pd.DataFrame(data, index=[&#x27;day1&#x27;, &#x27;day2&#x27;, &#x27;day3&#x27;])df[&#x27;Date&#x27;] = pd.to_datetime(df[&#x27;Date&#x27;]) #将Date列统一转换为Datetime格式print(df.to_string()) 去除内容错误数据对错误数据进行替换或移除 123456789101112131415person = &#123; &#x27;name&#x27;: [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Cindy&#x27;], &#x27;age&#x27;: [10, 12, 1333]&#125;df = pd.DataFrame(person)df.loc[2, &#x27;age&#x27;] = 13 #直接修改数据#若年龄大于100则默认修改为20for x in df.index: if df.loc[x, &#x27;age&#x27;] &gt; 100: df.loc[x, &#x27;age&#x27;] = 20 #或df.drop(x, inplace=True)将年龄大于100的行删除print(df.to_string()) 去除重复数据 通过duplicated()检测重复数据 通过drop_duplicates()删除重复数据12345678910person = &#123; &#x27;name&#x27;: [&#x27;Alice&#x27;, &#x27;Bob&#x27;, &#x27;Bob&#x27;, &#x27;Cindy&#x27;], &#x27;age&#x27;: [10, 12, 12, 1333]&#125;df = pd.DataFrame(person)print(df.duplicated()) #重复数据返回Truedf.drop_duplicates(inplace=True) #删除重复行print(df)","categories":[{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"summary","slug":"summary","permalink":"https://zielorem.github.io/tags/summary/"}]},{"title":"Encantado de conocerte en el mundo","slug":"my-first-blog","date":"2022-09-18T09:55:43.000Z","updated":"2025-05-30T04:39:27.293Z","comments":true,"path":"2022/09/18/my-first-blog/","link":"","permalink":"https://zielorem.github.io/2022/09/18/my-first-blog/","excerpt":"","text":"成功建站！极简风格的小博客，以后将自己的学习过程以及其中的小心得和小思考码在这里ww 1print(&#x27;hello world!&#x27;)","categories":[],"tags":[]}],"categories":[{"name":"opinion_dynamics","slug":"opinion-dynamics","permalink":"https://zielorem.github.io/categories/opinion-dynamics/"},{"name":"coding","slug":"coding","permalink":"https://zielorem.github.io/categories/coding/"}],"tags":[{"name":"polarization","slug":"polarization","permalink":"https://zielorem.github.io/tags/polarization/"},{"name":"algorithm","slug":"algorithm","permalink":"https://zielorem.github.io/tags/algorithm/"},{"name":"summary","slug":"summary","permalink":"https://zielorem.github.io/tags/summary/"}]}